/// <reference types="node" />
declare module "events" {
    export interface Disposable {
        /**
         * Dispose this object.
         */
        dispose(): void;
    }
    export namespace Disposable {
        function create(func: () => void): Disposable;
    }
    /**
     * Represents a typed event.
     */
    export interface Event<T> {
        /**
         *
         * @param listener The listener function will be call when the event happens.
         * @param thisArgs The 'this' which will be used when calling the event listener.
         * @param disposables An array to which a {{IDisposable}} will be added. The
         * @return
        */
        (listener: (e: T) => any, thisArgs?: any, disposables?: Disposable[]): Disposable;
    }
    export namespace Event {
        const None: Event<any>;
    }
    export interface EmitterOptions {
        onFirstListenerAdd?: Function;
        onLastListenerRemove?: Function;
    }
    export class Emitter<T> {
        private _options;
        private static _noop;
        private _event;
        private _callbacks;
        constructor(_options?: EmitterOptions);
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        readonly event: Event<T>;
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        fire(event: T): any;
        dispose(): void;
    }
}
declare module "is" {
    export function defined(value: any): boolean;
    export function undefined(value: any): boolean;
    export function nil(value: any): boolean;
    export function boolean(value: any): value is boolean;
    export function string(value: any): value is string;
    export function number(value: any): value is number;
    export function error(value: any): value is Error;
    export function func(value: any): value is Function;
    export function array<T>(value: any): value is T[];
    export function stringArray(value: any): value is string[];
}
declare module "cancellation" {
    import { Event } from "events";
    /**
     * Defines a CancellationToken. This interface is not
     * intended to be implemented. A CancellationToken must
     * be created via a CancellationTokenSource.
     */
    export interface CancellationToken {
        /**
         * Is `true` when the token has been cancelled, `false` otherwise.
         */
        readonly isCancellationRequested: boolean;
        /**
         * An [event](#Event) which fires upon cancellation.
         */
        readonly onCancellationRequested: Event<any>;
    }
    export namespace CancellationToken {
        const None: CancellationToken;
        const Cancelled: CancellationToken;
        function is(value: any): value is CancellationToken;
    }
    export class CancellationTokenSource {
        private _token;
        readonly token: CancellationToken;
        cancel(): void;
        dispose(): void;
    }
}
declare module "messages" {
    /**
     * A language server message
     */
    export interface Message {
        jsonrpc: string;
    }
    /**
     * Request message
     */
    export interface RequestMessage extends Message {
        /**
         * The request id.
         */
        id: number | string;
        /**
         * The method to be invoked.
         */
        method: string;
        /**
         * The method's params.
         */
        params?: any;
    }
    /**
     * Predefined error codes.
     */
    export namespace ErrorCodes {
        const ParseError: number;
        const InvalidRequest: number;
        const MethodNotFound: number;
        const InvalidParams: number;
        const InternalError: number;
        const serverErrorStart: number;
        const serverErrorEnd: number;
        const MessageWriteError: number;
        const MessageReadError: number;
    }
    export interface ResponseErrorLiteral<D> {
        /**
         * A number indicating the error type that occured.
         */
        code: number;
        /**
         * A string providing a short decription of the error.
         */
        message: string;
        /**
         * A Primitive or Structured value that contains additional
         * information about the error. Can be omitted.
         */
        data?: D;
    }
    /**
     * A error object return in a response in case a request
     * has failed.
     */
    export class ResponseError<D> extends Error {
        code: number;
        message: string;
        data: D;
        constructor(code: number, message: string, data?: D);
        toJson(): ResponseErrorLiteral<D>;
    }
    /**
     * A response message.
     */
    export interface ResponseMessage extends Message {
        /**
         * The request id.
         */
        id: number | string;
        /**
         * The result of a request. This can be omitted in
         * the case of an error.
         */
        result?: any;
        /**
         * The error object in case a request fails.
         */
        error?: ResponseErrorLiteral<any>;
    }
    /**
     * An interface to type messages.
     */
    export interface MessageType {
        method: string;
    }
    /**
     * End marker interface for request and notification types.
     */
    export interface _EM {
        _$endMarker$_: number;
    }
    /**
     * A interface to type the request parameter / response pair
     */
    export interface RequestType0<R, E, RO> extends MessageType {
        _?: [R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType<P, R, E, RO> extends MessageType {
        _?: [P, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType1<P1, R, E, RO> extends MessageType {
        _?: [P1, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType2<P1, P2, R, E, RO> extends MessageType {
        _?: [P1, P2, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType3<P1, P2, P3, R, E, RO> extends MessageType {
        _?: [P1, P2, P3, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType4<P1, P2, P3, P4, R, E, RO> extends MessageType {
        _?: [P1, P2, P3, P4, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType5<P1, P2, P3, P4, P5, R, E, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType6<P1, P2, P3, P4, P5, P6, R, E, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType7<P1, P2, P3, P4, P5, P6, P7, R, E, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, P7, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType8<P1, P2, P3, P4, P5, P6, P7, P8, R, E, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, P7, P8, R, E, RO, _EM];
        registerOptions?: RO;
    }
    export interface RequestType9<P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E, RO, _EM];
        registerOptions?: RO;
    }
    /**
     * Notification Message
     */
    export interface NotificationMessage extends Message {
        /**
         * The method to be invoked.
         */
        method: string;
        /**
         * The notification's params.
         */
        params?: any;
    }
    /**
     * An interface to type notification messages.
     */
    export interface NotificationType<P, RO> extends MessageType {
        _?: [P, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType0<RO> extends MessageType {
        _?: [RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType1<P1, RO> extends MessageType {
        _?: [P1, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType2<P1, P2, RO> extends MessageType {
        _?: [P1, P2, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType3<P1, P2, P3, RO> extends MessageType {
        _?: [P1, P2, P3, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType4<P1, P2, P3, P4, RO> extends MessageType {
        _?: [P1, P2, P3, P4, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType5<P1, P2, P3, P4, P5, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType6<P1, P2, P3, P4, P5, P6, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType7<P1, P2, P3, P4, P5, P6, P7, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, P7, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType8<P1, P2, P3, P4, P5, P6, P7, P8, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, P7, P8, RO, _EM];
        registerOptions?: RO;
    }
    export interface NotificationType9<P1, P2, P3, P4, P5, P6, P7, P8, P9, RO> extends MessageType {
        _?: [P1, P2, P3, P4, P5, P6, P7, P8, P9, RO, _EM];
        registerOptions?: RO;
    }
    /**
     * Tests if the given message is a request message
     */
    export function isRequestMessage(message: Message): message is RequestMessage;
    /**
     * Tests if the given message is a notification message
     */
    export function isNotificationMessage(message: Message): message is NotificationMessage;
    /**
     * Tests if the given message is a response message
     */
    export function isReponseMessage(message: Message): message is ResponseMessage;
}
declare module "messageReader" {
    import { ChildProcess } from 'child_process';
    import { Message } from "messages";
    import { Event } from "events";
    export interface DataCallback {
        (data: Message): void;
    }
    export interface PartialMessageInfo {
        readonly messageToken: number;
        readonly waitingTime: number;
    }
    export interface MessageReader {
        readonly onError: Event<Error>;
        readonly onClose: Event<void>;
        readonly onPartialMessage: Event<PartialMessageInfo>;
        listen(callback: DataCallback): void;
    }
    export abstract class AbstractMessageReader {
        private errorEmitter;
        private closeEmitter;
        private partialMessageEmitter;
        constructor();
        readonly onError: Event<Error>;
        protected fireError(error: any): void;
        readonly onClose: Event<void>;
        protected fireClose(): void;
        readonly onPartialMessage: Event<PartialMessageInfo>;
        protected firePartialMessage(info: PartialMessageInfo): void;
        private asError(error);
    }
    export class StreamMessageReader extends AbstractMessageReader implements MessageReader {
        private readable;
        private callback;
        private buffer;
        private nextMessageLength;
        private messageToken;
        private partialMessageTimer;
        private _partialMessageTimeout;
        constructor(readable: NodeJS.ReadableStream, encoding?: string);
        partialMessageTimeout: number;
        listen(callback: DataCallback): void;
        private onData(data);
        private clearPartialMessageTimer();
        private setPartialMessageTimer();
    }
    export class IPCMessageReader extends AbstractMessageReader implements MessageReader {
        private process;
        constructor(process: NodeJS.Process | ChildProcess);
        listen(callback: DataCallback): void;
    }
}
declare module "messageWriter" {
    import { ChildProcess } from 'child_process';
    import { Message } from "messages";
    import { Event } from "events";
    export interface MessageWriter {
        readonly onError: Event<[Error, Message | undefined, number | undefined]>;
        readonly onClose: Event<void>;
        write(msg: Message): void;
    }
    export abstract class AbstractMessageWriter {
        private errorEmitter;
        private closeEmitter;
        constructor();
        readonly onError: Event<[Error, Message, number]>;
        protected fireError(error: any, message?: Message, count?: number): void;
        readonly onClose: Event<void>;
        protected fireClose(): void;
        private asError(error);
    }
    export class StreamMessageWriter extends AbstractMessageWriter implements MessageWriter {
        private writable;
        private encoding;
        private errorCount;
        constructor(writable: NodeJS.WritableStream, encoding?: string);
        write(msg: Message): void;
    }
    export class IPCMessageWriter extends AbstractMessageWriter implements MessageWriter {
        private process;
        private errorCount;
        constructor(process: NodeJS.Process | ChildProcess);
        write(msg: Message): void;
    }
}
interface Thenable<T> extends PromiseLike<T> {
}
declare module "vscode-jsonrpc" {
    import { Message, MessageType, RequestMessage, RequestType, RequestType0, RequestType1, RequestType2, RequestType3, RequestType4, RequestType5, RequestType6, RequestType7, RequestType8, RequestType9, ResponseError, ErrorCodes, NotificationMessage, NotificationType, NotificationType0, NotificationType1, NotificationType2, NotificationType3, NotificationType4, NotificationType5, NotificationType6, NotificationType7, NotificationType8, NotificationType9 } from "messages";
    import { MessageReader, PartialMessageInfo, DataCallback, StreamMessageReader, IPCMessageReader } from "messageReader";
    import { MessageWriter, StreamMessageWriter, IPCMessageWriter } from "messageWriter";
    import { Disposable, Event, Emitter } from "events";
    import { CancellationTokenSource, CancellationToken } from "cancellation";
    export { Message, MessageType, ErrorCodes, ResponseError, RequestMessage, RequestType, RequestType0, RequestType1, RequestType2, RequestType3, RequestType4, RequestType5, RequestType6, RequestType7, RequestType8, RequestType9, NotificationMessage, NotificationType, NotificationType0, NotificationType1, NotificationType2, NotificationType3, NotificationType4, NotificationType5, NotificationType6, NotificationType7, NotificationType8, NotificationType9, MessageReader, PartialMessageInfo, DataCallback, StreamMessageReader, IPCMessageReader, MessageWriter, StreamMessageWriter, IPCMessageWriter, CancellationTokenSource, CancellationToken, Disposable, Event, Emitter };
    export interface GenericRequestHandler<R, E> {
        (...params: any[]): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler0<R, E> {
        (token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler<P, R, E> {
        (params: P, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler1<P1, R, E> {
        (p1: P1, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler2<P1, P2, R, E> {
        (p1: P1, p2: P2, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler3<P1, P2, P3, R, E> {
        (p1: P1, p2: P2, p3: P3, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler4<P1, P2, P3, P4, R, E> {
        (p1: P1, p2: P2, p3: P3, p4: P4, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler5<P1, P2, P3, P4, P5, R, E> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler6<P1, P2, P3, P4, P5, P6, R, E> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler7<P1, P2, P3, P4, P5, P6, P7, R, E> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler8<P1, P2, P3, P4, P5, P6, P7, P8, R, E> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface RequestHandler9<P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9, token: CancellationToken): R | ResponseError<E> | Thenable<R> | Thenable<ResponseError<E>>;
    }
    export interface GenericNotificationHandler {
        (...params: any[]): void;
    }
    export interface NotificationHandler0 {
        (): void;
    }
    export interface NotificationHandler<P> {
        (params: P): void;
    }
    export interface NotificationHandler1<P1> {
        (p1: P1): void;
    }
    export interface NotificationHandler2<P1, P2> {
        (p1: P1, p2: P2): void;
    }
    export interface NotificationHandler3<P1, P2, P3> {
        (p1: P1, p2: P2, p3: P3): void;
    }
    export interface NotificationHandler4<P1, P2, P3, P4> {
        (p1: P1, p2: P2, p3: P3, p4: P4): void;
    }
    export interface NotificationHandler5<P1, P2, P3, P4, P5> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5): void;
    }
    export interface NotificationHandler6<P1, P2, P3, P4, P5, P6> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6): void;
    }
    export interface NotificationHandler7<P1, P2, P3, P4, P5, P6, P7> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7): void;
    }
    export interface NotificationHandler8<P1, P2, P3, P4, P5, P6, P7, P8> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8): void;
    }
    export interface NotificationHandler9<P1, P2, P3, P4, P5, P6, P7, P8, P9> {
        (p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9): void;
    }
    export interface Logger {
        error(message: string): void;
        warn(message: string): void;
        info(message: string): void;
        log(message: string): void;
    }
    export enum Trace {
        Off = 0,
        Messages = 1,
        Verbose = 2,
    }
    export type TraceValues = 'off' | 'messages' | 'verbose';
    export namespace Trace {
        function fromString(value: string): Trace;
        function toString(value: Trace): TraceValues;
    }
    export interface SetTraceParams {
        value: TraceValues;
    }
    export namespace SetTraceNotification {
        const type: NotificationType<SetTraceParams, void>;
    }
    export interface LogTraceParams {
        message: string;
        verbose?: string;
    }
    export namespace LogTraceNotification {
        const type: NotificationType<LogTraceParams, void>;
    }
    export interface Tracer {
        log(message: string, data?: string): void;
    }
    export interface MessageConnection {
        sendRequest<R, E, RO>(type: RequestType0<R, E, RO>, token?: CancellationToken): Thenable<R>;
        sendRequest<P, R, E, RO>(type: RequestType<P, R, E, RO>, params: P, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, R, E, RO>(type: RequestType1<P1, R, E, RO>, p1: P1, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, R, E, RO>(type: RequestType2<P1, P2, R, E, RO>, p1: P1, p2: P2, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, P3, R, E, RO>(type: RequestType3<P1, P2, P3, R, E, RO>, p1: P1, p2: P2, p3: P3, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, P3, P4, R, E, RO>(type: RequestType4<P1, P2, P3, P4, R, E, RO>, p1: P1, p2: P2, p3: P3, p4: P4, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, P3, P4, P5, R, E, RO>(type: RequestType5<P1, P2, P3, P4, P5, R, E, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, P3, P4, P5, P6, R, E, RO>(type: RequestType6<P1, P2, P3, P4, P5, P6, R, E, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, P3, P4, P5, P6, P7, R, E, RO>(type: RequestType7<P1, P2, P3, P4, P5, P6, P7, R, E, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, P3, P4, P5, P6, P7, P8, R, E, RO>(type: RequestType8<P1, P2, P3, P4, P5, P6, P7, P8, R, E, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, token?: CancellationToken): Thenable<R>;
        sendRequest<P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E, RO>(type: RequestType9<P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9, token?: CancellationToken): Thenable<R>;
        sendRequest<R>(method: string, ...params: any[]): Thenable<R>;
        onRequest<R, E, RO>(type: RequestType0<R, E, RO>, handler: RequestHandler0<R, E>): void;
        onRequest<P, R, E, RO>(type: RequestType<P, R, E, RO>, handler: RequestHandler<P, R, E>): void;
        onRequest<P1, R, E, RO>(type: RequestType1<P1, R, E, RO>, handler: RequestHandler1<P1, R, E>): void;
        onRequest<P1, P2, R, E, RO>(type: RequestType2<P1, P2, R, E, RO>, handler: RequestHandler2<P1, P2, R, E>): void;
        onRequest<P1, P2, P3, R, E, RO>(type: RequestType3<P1, P2, P3, R, E, RO>, handler: RequestHandler3<P1, P2, P3, R, E>): void;
        onRequest<P1, P2, P3, P4, R, E, RO>(type: RequestType4<P1, P2, P3, P4, R, E, RO>, handler: RequestHandler4<P1, P2, P3, P4, R, E>): void;
        onRequest<P1, P2, P3, P4, P5, R, E, RO>(type: RequestType5<P1, P2, P3, P4, P5, R, E, RO>, handler: RequestHandler5<P1, P2, P3, P4, P5, R, E>): void;
        onRequest<P1, P2, P3, P4, P5, P6, R, E, RO>(type: RequestType6<P1, P2, P3, P4, P5, P6, R, E, RO>, handler: RequestHandler6<P1, P2, P3, P4, P5, P6, R, E>): void;
        onRequest<P1, P2, P3, P4, P5, P6, P7, R, E, RO>(type: RequestType7<P1, P2, P3, P4, P5, P6, P7, R, E, RO>, handler: RequestHandler7<P1, P2, P3, P4, P5, P6, P7, R, E>): void;
        onRequest<P1, P2, P3, P4, P5, P6, P7, P8, R, E, RO>(type: RequestType8<P1, P2, P3, P4, P5, P6, P7, P8, R, E, RO>, handler: RequestHandler8<P1, P2, P3, P4, P5, P6, P7, P8, R, E>): void;
        onRequest<P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E, RO>(type: RequestType9<P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E, RO>, handler: RequestHandler9<P1, P2, P3, P4, P5, P6, P7, P8, P9, R, E>): void;
        onRequest<R, E>(method: string, handler: GenericRequestHandler<R, E>): void;
        sendNotification<RO>(type: NotificationType0<RO>): void;
        sendNotification<P, RO>(type: NotificationType<P, RO>, params?: P): void;
        sendNotification<P1, RO>(type: NotificationType1<P1, RO>, p1: P1): void;
        sendNotification<P1, P2, RO>(type: NotificationType2<P1, P2, RO>, p1: P1, p2: P2): void;
        sendNotification<P1, P2, P3, RO>(type: NotificationType3<P1, P2, P3, RO>, p1: P1, p2: P2, p3: P3): void;
        sendNotification<P1, P2, P3, P4, RO>(type: NotificationType4<P1, P2, P3, P4, RO>, p1: P1, p2: P2, p3: P3, p4: P4): void;
        sendNotification<P1, P2, P3, P4, P5, RO>(type: NotificationType5<P1, P2, P3, P4, P5, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5): void;
        sendNotification<P1, P2, P3, P4, P5, P6, RO>(type: NotificationType6<P1, P2, P3, P4, P5, P6, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6): void;
        sendNotification<P1, P2, P3, P4, P5, P6, P7, RO>(type: NotificationType7<P1, P2, P3, P4, P5, P6, P7, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7): void;
        sendNotification<P1, P2, P3, P4, P5, P6, P7, P8, RO>(type: NotificationType8<P1, P2, P3, P4, P5, P6, P7, P8, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8): void;
        sendNotification<P1, P2, P3, P4, P5, P6, P7, P8, P9, RO>(type: NotificationType9<P1, P2, P3, P4, P5, P6, P7, P8, P9, RO>, p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9): void;
        sendNotification(method: string, ...params: any[]): void;
        onNotification<RO>(type: NotificationType0<RO>, handler: NotificationHandler0): void;
        onNotification<P, RO>(type: NotificationType<P, RO>, handler: NotificationHandler<P>): void;
        onNotification<P1, RO>(type: NotificationType1<P1, RO>, handler: NotificationHandler1<P1>): void;
        onNotification<P1, P2, RO>(type: NotificationType2<P1, P2, RO>, handler: NotificationHandler2<P1, P2>): void;
        onNotification<P1, P2, P3, RO>(type: NotificationType3<P1, P2, P3, RO>, handler: NotificationHandler3<P1, P2, P3>): void;
        onNotification<P1, P2, P3, P4, RO>(type: NotificationType4<P1, P2, P3, P4, RO>, handler: NotificationHandler4<P1, P2, P3, P4>): void;
        onNotification<P1, P2, P3, P4, P5, RO>(type: NotificationType5<P1, P2, P3, P4, P5, RO>, handler: NotificationHandler5<P1, P2, P3, P4, P5>): void;
        onNotification<P1, P2, P3, P4, P5, P6, RO>(type: NotificationType6<P1, P2, P3, P4, P5, P6, RO>, handler: NotificationHandler6<P1, P2, P3, P4, P5, P6>): void;
        onNotification<P1, P2, P3, P4, P5, P6, P7, RO>(type: NotificationType7<P1, P2, P3, P4, P5, P6, P7, RO>, handler: NotificationHandler7<P1, P2, P3, P4, P5, P6, P7>): void;
        onNotification<P1, P2, P3, P4, P5, P6, P7, P8, RO>(type: NotificationType8<P1, P2, P3, P4, P5, P6, P7, P8, RO>, handler: NotificationHandler8<P1, P2, P3, P4, P5, P6, P7, P8>): void;
        onNotification<P1, P2, P3, P4, P5, P6, P7, P8, P9, RO>(type: NotificationType9<P1, P2, P3, P4, P5, P6, P7, P8, P9, RO>, handler: NotificationHandler9<P1, P2, P3, P4, P5, P6, P7, P8, P9>): void;
        onNotification(method: string, handler: GenericNotificationHandler): void;
        trace(value: Trace, tracer: Tracer, sendNotification?: boolean): void;
        onError: Event<[Error, Message, number]>;
        onClose: Event<void>;
        onUnhandledNotification: Event<NotificationMessage>;
        listen(): void;
        onDispose: Event<void>;
        dispose(): void;
    }
    export function createMessageConnection(reader: MessageReader, writer: MessageWriter, logger: Logger): MessageConnection;
    export function createMessageConnection(inputStream: NodeJS.ReadableStream, outputStream: NodeJS.WritableStream, logger: Logger): MessageConnection;
}
