var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("events", ["require", "exports"], function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var Disposable;
    (function (Disposable) {
        function create(func) {
            return {
                dispose: func
            };
        }
        Disposable.create = create;
    })(Disposable = exports.Disposable || (exports.Disposable = {}));
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event = exports.Event || (exports.Event = {}));
    /**
     * Represents a type which can release resources, such
     * as event listening or a timer.
     */
    var DisposableImpl = (function () {
        function DisposableImpl(callOnDispose) {
            this._callOnDispose = callOnDispose;
        }
        /**
         * Combine many disposable-likes into one. Use this method
         * when having objects with a dispose function which are not
         * instances of Disposable.
         *
         * @return Returns a new disposable which, upon dispose, will
         * dispose all provides disposable-likes.
         */
        DisposableImpl.from = function () {
            var _disposables = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                _disposables[_i - 0] = arguments[_i];
            }
            return new DisposableImpl(function () {
                var disposables = _disposables;
                if (disposables) {
                    for (var _i = 0, disposables_1 = disposables; _i < disposables_1.length; _i++) {
                        var disposable = disposables_1[_i];
                        disposable.dispose();
                    }
                    disposables = undefined;
                }
            });
        };
        /**
         * Dispose this object.
         */
        DisposableImpl.prototype.dispose = function () {
            if (typeof this._callOnDispose === 'function') {
                this._callOnDispose();
                this._callOnDispose = undefined;
            }
        };
        return DisposableImpl;
    }());
    var CallbackList = (function () {
        function CallbackList() {
        }
        CallbackList.prototype.add = function (callback, context, bucket) {
            var _this = this;
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                this._callbacks = [];
                this._contexts = [];
            }
            this._callbacks.push(callback);
            this._contexts.push(context);
            if (Array.isArray(bucket)) {
                bucket.push({ dispose: function () { return _this.remove(callback, context); } });
            }
        };
        CallbackList.prototype.remove = function (callback, context) {
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                return;
            }
            var foundCallbackWithDifferentContext = false;
            for (var i = 0, len = this._callbacks.length; i < len; i++) {
                if (this._callbacks[i] === callback) {
                    if (this._contexts[i] === context) {
                        // callback & context match => remove it
                        this._callbacks.splice(i, 1);
                        this._contexts.splice(i, 1);
                        return;
                    }
                    else {
                        foundCallbackWithDifferentContext = true;
                    }
                }
            }
            if (foundCallbackWithDifferentContext) {
                throw new Error('When adding a listener with a context, you should remove it with the same context');
            }
        };
        CallbackList.prototype.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (!this._callbacks) {
                return [];
            }
            var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
            for (var i = 0, len = callbacks.length; i < len; i++) {
                try {
                    ret.push(callbacks[i].apply(contexts[i], args));
                }
                catch (e) {
                    console.error(e);
                }
            }
            return ret;
        };
        CallbackList.prototype.isEmpty = function () {
            return !this._callbacks || this._callbacks.length === 0;
        };
        CallbackList.prototype.dispose = function () {
            this._callbacks = undefined;
            this._contexts = undefined;
        };
        return CallbackList;
    }());
    var Emitter = (function () {
        function Emitter(_options) {
            this._options = _options;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._callbacks) {
                            _this._callbacks = new CallbackList();
                        }
                        if (_this._options && _this._options.onFirstListenerAdd && _this._callbacks.isEmpty()) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        _this._callbacks.add(listener, thisArgs);
                        var result;
                        result = {
                            dispose: function () {
                                _this._callbacks.remove(listener, thisArgs);
                                result.dispose = Emitter._noop;
                                if (_this._options && _this._options.onLastListenerRemove && _this._callbacks.isEmpty()) {
                                    _this._options.onLastListenerRemove(_this);
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._callbacks) {
                this._callbacks.invoke.call(this._callbacks, event);
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._callbacks) {
                this._callbacks.dispose();
                this._callbacks = undefined;
            }
        };
        Emitter._noop = function () { };
        return Emitter;
    }());
    exports.Emitter = Emitter;
});
define("is", ["require", "exports"], function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    exports.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    exports.undefined = undefined;
    function nil(value) {
        return value === null;
    }
    exports.nil = nil;
    function boolean(value) {
        return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    exports.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    exports.number = number;
    function error(value) {
        return toString.call(value) === '[object Error]';
    }
    exports.error = error;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    exports.func = func;
    function array(value) {
        return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
        return array(value) && value.every(function (elem) { return string(elem); });
    }
    exports.stringArray = stringArray;
});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define("cancellation", ["require", "exports", "events", "is"], function (require, exports, events_1, Is) {
    'use strict';
    var CancellationToken;
    (function (CancellationToken) {
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: events_1.Event.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: events_1.Event.None
        });
        function is(value) {
            var candidate = value;
            return candidate && (candidate === CancellationToken.None
                || candidate === CancellationToken.Cancelled
                || (Is.boolean(candidate.isCancellationRequested) && Is.defined(candidate.onCancellationRequested)));
        }
        CancellationToken.is = is;
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var MutableToken = (function () {
        function MutableToken() {
            this._isCancelled = false;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this._emitter = undefined;
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new events_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return MutableToken;
    }());
    var CancellationTokenSource = (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else {
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            this.cancel();
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});
define("messages", ["require", "exports", "is"], function (require, exports, is) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    /**
     * Predefined error codes.
     */
    var ErrorCodes;
    (function (ErrorCodes) {
        // Defined by JSON RPC
        ErrorCodes.ParseError = -32700;
        ErrorCodes.InvalidRequest = -32600;
        ErrorCodes.MethodNotFound = -32601;
        ErrorCodes.InvalidParams = -32602;
        ErrorCodes.InternalError = -32603;
        ErrorCodes.serverErrorStart = -32099;
        ErrorCodes.serverErrorEnd = -32000;
        // Defined by VSCode.
        ErrorCodes.MessageWriteError = 1;
        ErrorCodes.MessageReadError = 2;
    })(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
    /**
     * A error object return in a response in case a request
     * has failed.
     */
    var ResponseError = (function (_super) {
        __extends(ResponseError, _super);
        function ResponseError(code, message, data) {
            _super.call(this, message);
            this.code = code;
            this.message = message;
            if (data && is.defined(data)) {
                this.data = data;
            }
        }
        ResponseError.prototype.toJson = function () {
            var result = {
                code: this.code,
                message: this.message
            };
            if (is.defined(this.data)) {
                result.data = this.data;
            }
            ;
            return result;
        };
        return ResponseError;
    }(Error));
    exports.ResponseError = ResponseError;
    /**
     * Tests if the given message is a request message
     */
    function isRequestMessage(message) {
        var candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports.isRequestMessage = isRequestMessage;
    /**
     * Tests if the given message is a notification message
     */
    function isNotificationMessage(message) {
        var candidate = message;
        return candidate && is.string(candidate.method) && is.undefined(message.id);
    }
    exports.isNotificationMessage = isNotificationMessage;
    /**
     * Tests if the given message is a response message
     */
    function isReponseMessage(message) {
        var candidate = message;
        return candidate && (is.defined(candidate.result) || is.defined(candidate.error)) && (is.string(candidate.id) || is.number(candidate.id));
    }
    exports.isReponseMessage = isReponseMessage;
});
define("messageReader", ["require", "exports", "events", "is"], function (require, exports, events_2, is) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var DefaultSize = 8192;
    var CR = new Buffer('\r', 'ascii')[0];
    var LF = new Buffer('\n', 'ascii')[0];
    var CRLF = '\r\n';
    var MessageBuffer = (function () {
        function MessageBuffer(encoding) {
            if (encoding === void 0) { encoding = 'utf-8'; }
            this.encoding = encoding;
            this.index = 0;
            this.buffer = new Buffer(DefaultSize);
        }
        MessageBuffer.prototype.append = function (chunk) {
            var toAppend = chunk;
            if (typeof (chunk) == 'string') {
                var str = chunk;
                toAppend = new Buffer(str.length);
                toAppend.write(str, 0, str.length, this.encoding);
            }
            if (this.buffer.length - this.index >= toAppend.length) {
                toAppend.copy(this.buffer, this.index, 0, toAppend.length);
            }
            else {
                var newSize = (Math.ceil((this.index + toAppend.length) / DefaultSize) + 1) * DefaultSize;
                if (this.index === 0) {
                    this.buffer = new Buffer(newSize);
                    toAppend.copy(this.buffer, 0, 0, toAppend.length);
                }
                else {
                    this.buffer = Buffer.concat([this.buffer.slice(0, this.index), toAppend], newSize);
                }
            }
            this.index += toAppend.length;
        };
        MessageBuffer.prototype.tryReadHeaders = function () {
            var result = undefined;
            var current = 0;
            while (current + 3 < this.index && (this.buffer[current] !== CR || this.buffer[current + 1] !== LF || this.buffer[current + 2] !== CR || this.buffer[current + 3] !== LF)) {
                current++;
            }
            // No header / body separator found (e.g CRLFCRLF)
            if (current + 3 >= this.index) {
                return result;
            }
            result = Object.create(null);
            var headers = this.buffer.toString('ascii', 0, current).split(CRLF);
            headers.forEach(function (header) {
                var index = header.indexOf(':');
                if (index === -1) {
                    throw new Error('Message header must separate key and value using :');
                }
                var key = header.substr(0, index);
                var value = header.substr(index + 1).trim();
                result[key] = value;
            });
            var nextStart = current + 4;
            this.buffer = this.buffer.slice(nextStart);
            this.index = this.index - nextStart;
            return result;
        };
        MessageBuffer.prototype.tryReadContent = function (length) {
            if (this.index < length) {
                return null;
            }
            var result = this.buffer.toString(this.encoding, 0, length);
            var nextStart = length;
            this.buffer.copy(this.buffer, 0, nextStart);
            this.index = this.index - nextStart;
            return result;
        };
        Object.defineProperty(MessageBuffer.prototype, "numberOfBytes", {
            get: function () {
                return this.index;
            },
            enumerable: true,
            configurable: true
        });
        return MessageBuffer;
    }());
    var AbstractMessageReader = (function () {
        function AbstractMessageReader() {
            this.errorEmitter = new events_2.Emitter();
            this.closeEmitter = new events_2.Emitter();
            this.partialMessageEmitter = new events_2.Emitter();
        }
        Object.defineProperty(AbstractMessageReader.prototype, "onError", {
            get: function () {
                return this.errorEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractMessageReader.prototype.fireError = function (error) {
            this.errorEmitter.fire(this.asError(error));
        };
        Object.defineProperty(AbstractMessageReader.prototype, "onClose", {
            get: function () {
                return this.closeEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractMessageReader.prototype.fireClose = function () {
            this.closeEmitter.fire(undefined);
        };
        Object.defineProperty(AbstractMessageReader.prototype, "onPartialMessage", {
            get: function () {
                return this.partialMessageEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractMessageReader.prototype.firePartialMessage = function (info) {
            this.partialMessageEmitter.fire(info);
        };
        AbstractMessageReader.prototype.asError = function (error) {
            if (error instanceof Error) {
                return error;
            }
            else {
                return new Error("Reader recevied error. Reason: " + (is.string(error.message) ? error.message : 'unknown'));
            }
        };
        return AbstractMessageReader;
    }());
    exports.AbstractMessageReader = AbstractMessageReader;
    var StreamMessageReader = (function (_super) {
        __extends(StreamMessageReader, _super);
        function StreamMessageReader(readable, encoding) {
            if (encoding === void 0) { encoding = 'utf-8'; }
            _super.call(this);
            this.readable = readable;
            this.buffer = new MessageBuffer(encoding);
            this._partialMessageTimeout = 10000;
        }
        Object.defineProperty(StreamMessageReader.prototype, "partialMessageTimeout", {
            get: function () {
                return this._partialMessageTimeout;
            },
            set: function (timeout) {
                this._partialMessageTimeout = timeout;
            },
            enumerable: true,
            configurable: true
        });
        StreamMessageReader.prototype.listen = function (callback) {
            var _this = this;
            this.nextMessageLength = -1;
            this.messageToken = 0;
            this.partialMessageTimer = undefined;
            this.callback = callback;
            this.readable.on('data', function (data) {
                _this.onData(data);
            });
            this.readable.on('error', function (error) { return _this.fireError(error); });
            this.readable.on('close', function () { return _this.fireClose(); });
        };
        StreamMessageReader.prototype.onData = function (data) {
            this.buffer.append(data);
            while (true) {
                if (this.nextMessageLength === -1) {
                    var headers = this.buffer.tryReadHeaders();
                    if (!headers) {
                        return;
                    }
                    var contentLength = headers['Content-Length'];
                    if (!contentLength) {
                        throw new Error('Header must provide a Content-Length property.');
                    }
                    var length = parseInt(contentLength);
                    if (isNaN(length)) {
                        throw new Error('Content-Length value must be a number.');
                    }
                    this.nextMessageLength = length;
                }
                var msg = this.buffer.tryReadContent(this.nextMessageLength);
                if (msg === null) {
                    /** We haven't recevied the full message yet. */
                    this.setPartialMessageTimer();
                    return;
                }
                this.clearPartialMessageTimer();
                this.nextMessageLength = -1;
                this.messageToken++;
                var json = JSON.parse(msg);
                this.callback(json);
            }
        };
        StreamMessageReader.prototype.clearPartialMessageTimer = function () {
            if (this.partialMessageTimer) {
                clearTimeout(this.partialMessageTimer);
                this.partialMessageTimer = undefined;
            }
        };
        StreamMessageReader.prototype.setPartialMessageTimer = function () {
            var _this = this;
            this.clearPartialMessageTimer();
            if (this._partialMessageTimeout <= 0) {
                return;
            }
            this.partialMessageTimer = setTimeout(function (token, timeout) {
                _this.partialMessageTimer = undefined;
                if (token === _this.messageToken) {
                    _this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                    _this.setPartialMessageTimer();
                }
            }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
        };
        return StreamMessageReader;
    }(AbstractMessageReader));
    exports.StreamMessageReader = StreamMessageReader;
    var IPCMessageReader = (function (_super) {
        __extends(IPCMessageReader, _super);
        function IPCMessageReader(process) {
            var _this = this;
            _super.call(this);
            this.process = process;
            var eventEmitter = this.process;
            eventEmitter.on('error', function (error) { return _this.fireError(error); });
            eventEmitter.on('close', function () { return _this.fireClose(); });
        }
        IPCMessageReader.prototype.listen = function (callback) {
            this.process.on('message', callback);
        };
        return IPCMessageReader;
    }(AbstractMessageReader));
    exports.IPCMessageReader = IPCMessageReader;
});
define("messageWriter", ["require", "exports", "events", "is"], function (require, exports, events_3, is) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var ContentLength = 'Content-Length: ';
    var CRLF = '\r\n';
    var AbstractMessageWriter = (function () {
        function AbstractMessageWriter() {
            this.errorEmitter = new events_3.Emitter();
            this.closeEmitter = new events_3.Emitter();
        }
        Object.defineProperty(AbstractMessageWriter.prototype, "onError", {
            get: function () {
                return this.errorEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractMessageWriter.prototype.fireError = function (error, message, count) {
            this.errorEmitter.fire([this.asError(error), message, count]);
        };
        Object.defineProperty(AbstractMessageWriter.prototype, "onClose", {
            get: function () {
                return this.closeEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractMessageWriter.prototype.fireClose = function () {
            this.closeEmitter.fire(undefined);
        };
        AbstractMessageWriter.prototype.asError = function (error) {
            if (error instanceof Error) {
                return error;
            }
            else {
                return new Error("Writer recevied error. Reason: " + (is.string(error.message) ? error.message : 'unknown'));
            }
        };
        return AbstractMessageWriter;
    }());
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var StreamMessageWriter = (function (_super) {
        __extends(StreamMessageWriter, _super);
        function StreamMessageWriter(writable, encoding) {
            var _this = this;
            if (encoding === void 0) { encoding = 'utf8'; }
            _super.call(this);
            this.writable = writable;
            this.encoding = encoding;
            this.errorCount = 0;
            this.writable.on('error', function (error) { return _this.fireError(error); });
            this.writable.on('close', function () { return _this.fireClose(); });
        }
        StreamMessageWriter.prototype.write = function (msg) {
            var json = JSON.stringify(msg);
            var contentLength = Buffer.byteLength(json, this.encoding);
            var headers = [
                ContentLength, contentLength.toString(), CRLF,
                CRLF
            ];
            try {
                // Header must be written in ASCII encoding
                this.writable.write(headers.join(''), 'ascii');
                // Now write the content. This can be written in any encoding
                this.writable.write(json, this.encoding);
                this.errorCount = 0;
            }
            catch (error) {
                this.errorCount++;
                this.fireError(error, msg, this.errorCount);
            }
        };
        return StreamMessageWriter;
    }(AbstractMessageWriter));
    exports.StreamMessageWriter = StreamMessageWriter;
    var IPCMessageWriter = (function (_super) {
        __extends(IPCMessageWriter, _super);
        function IPCMessageWriter(process) {
            var _this = this;
            _super.call(this);
            this.process = process;
            this.errorCount = 0;
            var eventEmitter = this.process;
            eventEmitter.on('error', function (error) { return _this.fireError(error); });
            eventEmitter.on('close', function () { return _this.fireClose; });
        }
        IPCMessageWriter.prototype.write = function (msg) {
            try {
                if (this.process.send) {
                    this.process.send(msg);
                    this.errorCount = 0;
                }
            }
            catch (error) {
                this.errorCount++;
                this.fireError(error, msg, this.errorCount);
            }
        };
        return IPCMessageWriter;
    }(AbstractMessageWriter));
    exports.IPCMessageWriter = IPCMessageWriter;
});
define("vscode-jsonrpc", ["require", "exports", "is", "messages", "messageReader", "messageWriter", "events", "cancellation"], function (require, exports, is, messages_1, messageReader_1, messageWriter_1, events_4, cancellation_1) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    /// <reference path="./thenable.ts" />
    'use strict';
    exports.ResponseError = messages_1.ResponseError;
    exports.ErrorCodes = messages_1.ErrorCodes;
    exports.StreamMessageReader = messageReader_1.StreamMessageReader;
    exports.IPCMessageReader = messageReader_1.IPCMessageReader;
    exports.StreamMessageWriter = messageWriter_1.StreamMessageWriter;
    exports.IPCMessageWriter = messageWriter_1.IPCMessageWriter;
    exports.Disposable = events_4.Disposable;
    exports.Event = events_4.Event;
    exports.Emitter = events_4.Emitter;
    exports.CancellationTokenSource = cancellation_1.CancellationTokenSource;
    exports.CancellationToken = cancellation_1.CancellationToken;
    var CancelNotification;
    (function (CancelNotification) {
        CancelNotification.type = { get method() { return '$/cancelRequest'; } };
    })(CancelNotification || (CancelNotification = {}));
    (function (Trace) {
        Trace[Trace["Off"] = 0] = "Off";
        Trace[Trace["Messages"] = 1] = "Messages";
        Trace[Trace["Verbose"] = 2] = "Verbose";
    })(exports.Trace || (exports.Trace = {}));
    var Trace = exports.Trace;
    var Trace;
    (function (Trace) {
        function fromString(value) {
            value = value.toLowerCase();
            switch (value) {
                case 'off':
                    return Trace.Off;
                case 'messages':
                    return Trace.Messages;
                case 'verbose':
                    return Trace.Verbose;
                default:
                    return Trace.Off;
            }
        }
        Trace.fromString = fromString;
        function toString(value) {
            switch (value) {
                case Trace.Off:
                    return 'off';
                case Trace.Messages:
                    return 'messages';
                case Trace.Verbose:
                    return 'verbose';
                default:
                    return 'off';
            }
        }
        Trace.toString = toString;
    })(Trace = exports.Trace || (exports.Trace = {}));
    var SetTraceNotification;
    (function (SetTraceNotification) {
        SetTraceNotification.type = { get method() { return '$/setTraceNotification'; } };
    })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
    var LogTraceNotification;
    (function (LogTraceNotification) {
        LogTraceNotification.type = { get method() { return '$/logTraceNotification'; } };
    })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
    var ConnectionState;
    (function (ConnectionState) {
        ConnectionState[ConnectionState["New"] = 1] = "New";
        ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
        ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
        ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function _createMessageConnection(messageReader, messageWriter, logger) {
        var sequenceNumber = 0;
        var version = '2.0';
        var requestHandlers = Object.create(null);
        var notificationHandlers = Object.create(null);
        var responsePromises = Object.create(null);
        var requestTokens = Object.create(null);
        var trace = Trace.Off;
        var tracer;
        var state = ConnectionState.New;
        var errorEmitter = new events_4.Emitter();
        var closeEmitter = new events_4.Emitter();
        var unhandledNotificationEmitter = new events_4.Emitter();
        var disposeEmitter = new events_4.Emitter();
        function isListening() {
            return state === ConnectionState.Listening;
        }
        function isClosed() {
            return state === ConnectionState.Closed;
        }
        function isDisposed() {
            return state === ConnectionState.Disposed;
        }
        function closeHandler() {
            if (state === ConnectionState.New || state === ConnectionState.Listening) {
                state = ConnectionState.Closed;
                closeEmitter.fire(undefined);
            }
            // If the connection is disposed don't sent close events.
        }
        ;
        function readErrorHandler(error) {
            errorEmitter.fire([error, undefined, undefined]);
        }
        function writeErrorHandler(data) {
            errorEmitter.fire(data);
        }
        messageReader.onClose(closeHandler);
        messageReader.onError(readErrorHandler);
        messageWriter.onClose(closeHandler);
        messageWriter.onError(writeErrorHandler);
        function handleRequest(requestMessage) {
            if (isDisposed()) {
                // we return here silently since we fired an event when the
                // connection got disposed.
                return;
            }
            function reply(resultOrError, method, startTime) {
                var message = {
                    jsonrpc: version,
                    id: requestMessage.id
                };
                if (resultOrError instanceof messages_1.ResponseError) {
                    message.error = resultOrError.toJson();
                }
                else {
                    message.result = is.undefined(resultOrError) ? null : resultOrError;
                }
                traceSendingResponse(message, method, startTime);
                messageWriter.write(message);
            }
            function replyError(error, method, startTime) {
                var message = {
                    jsonrpc: version,
                    id: requestMessage.id,
                    error: error.toJson()
                };
                traceSendingResponse(message, method, startTime);
                messageWriter.write(message);
            }
            function replySuccess(result, method, startTime) {
                // The JSON RPC defines that a response must either have a result or an error
                // So we can't treat undefined as a valid response result.
                if (is.undefined(result)) {
                    result = null;
                }
                var message = {
                    jsonrpc: version,
                    id: requestMessage.id,
                    result: result
                };
                traceSendingResponse(message, method, startTime);
                messageWriter.write(message);
            }
            traceReceviedRequest(requestMessage);
            var requestHandler = requestHandlers[requestMessage.method];
            var startTime = Date.now();
            if (requestHandler) {
                var cancellationSource = new cancellation_1.CancellationTokenSource();
                var tokenKey_1 = String(requestMessage.id);
                requestTokens[tokenKey_1] = cancellationSource;
                try {
                    var handlerResult = void 0;
                    if (is.nil(requestMessage.params)) {
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (is.array(requestMessage.params)) {
                        handlerResult = requestHandler.apply(void 0, requestMessage.params.concat([cancellationSource.token]));
                    }
                    else {
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                    var promise = handlerResult;
                    if (!handlerResult) {
                        delete requestTokens[tokenKey_1];
                        replySuccess(handlerResult, requestMessage.method, startTime);
                    }
                    else if (promise.then) {
                        promise.then(function (resultOrError) {
                            delete requestTokens[tokenKey_1];
                            reply(resultOrError, requestMessage.method, startTime);
                        }, function (error) {
                            delete requestTokens[tokenKey_1];
                            if (error instanceof messages_1.ResponseError) {
                                replyError(error, requestMessage.method, startTime);
                            }
                            else if (error && is.string(error.message)) {
                                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed with message: " + error.message), requestMessage.method, startTime);
                            }
                            else {
                                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed unexpectedly without providing any details."), requestMessage.method, startTime);
                            }
                        });
                    }
                    else {
                        delete requestTokens[tokenKey_1];
                        reply(handlerResult, requestMessage.method, startTime);
                    }
                }
                catch (error) {
                    delete requestTokens[tokenKey_1];
                    if (error instanceof messages_1.ResponseError) {
                        reply(error, requestMessage.method, startTime);
                    }
                    else if (error && is.string(error.message)) {
                        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed with message: " + error.message), requestMessage.method, startTime);
                    }
                    else {
                        replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, "Request " + requestMessage.method + " failed unexpectedly without providing any details."), requestMessage.method, startTime);
                    }
                }
            }
            else {
                replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, "Unhandled method " + requestMessage.method), requestMessage.method, startTime);
            }
        }
        function handleResponse(responseMessage) {
            if (isDisposed()) {
                // See handle request.
                return;
            }
            var key = String(responseMessage.id);
            var responsePromise = responsePromises[key];
            traceReceviedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error && is.defined(responseMessage.error)) {
                        var error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (is.defined(responseMessage.result)) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error("Response handler '" + responsePromise.method + "' failed with message: " + error.message);
                    }
                    else {
                        logger.error("Response handler '" + responsePromise.method + "' failed unexpectedly.");
                    }
                }
            }
        }
        function handleNotification(message) {
            if (isDisposed()) {
                // See handle request.
                return;
            }
            var notificationHandler;
            if (message.method === CancelNotification.type.method) {
                notificationHandler = function (params) {
                    var id = params.id;
                    var source = requestTokens[String(id)];
                    if (source) {
                        source.cancel();
                    }
                };
            }
            else {
                notificationHandler = notificationHandlers[message.method];
            }
            if (notificationHandler) {
                try {
                    traceReceivedNotification(message);
                    if (is.nil(message.params)) {
                        notificationHandler();
                    }
                    else if (is.array(message.params)) {
                        notificationHandler.apply(void 0, message.params);
                    }
                    else {
                        notificationHandler(message.params);
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error("Notification handler '" + message.method + "' failed with message: " + error.message);
                    }
                    else {
                        logger.error("Notification handler '" + message.method + "' failed unexpectedly.");
                    }
                }
            }
            else {
                unhandledNotificationEmitter.fire(message);
            }
        }
        function handleInvalidMessage(message) {
            if (!message) {
                logger.error('Received empty message.');
                return;
            }
            logger.error("Received message which is neither a response nor a notification message:\n" + JSON.stringify(message, null, 4));
            // Test whether we find an id to reject the promise
            var responseMessage = message;
            if (is.string(responseMessage.id) || is.number(responseMessage.id)) {
                var key = String(responseMessage.id);
                var responseHandler = responsePromises[key];
                if (responseHandler) {
                    responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
                }
            }
        }
        function traceSendingRequest(message) {
            if (trace === Trace.Off || !tracer) {
                return;
            }
            var data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
            }
            tracer.log("Sending request '" + message.method + " - (" + message.id + ")'.", data);
        }
        function traceSendNotification(message) {
            if (trace === Trace.Off || !tracer) {
                return;
            }
            var data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log("Sending notification '" + message.method + "'.", data);
        }
        function traceSendingResponse(message, method, startTime) {
            if (trace === Trace.Off || !tracer) {
                return;
            }
            var data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = "Error data: " + JSON.stringify(message.error.data, null, 4) + "\n\n";
                }
                else {
                    if (message.result) {
                        data = "Result: " + JSON.stringify(message.result, null, 4) + "\n\n";
                    }
                    else if (is.undefined(message.error)) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log("Sending response '" + method + " - (" + message.id + ")'. Processing request took " + (Date.now() - startTime) + "ms");
        }
        function traceReceviedRequest(message) {
            if (trace === Trace.Off || !tracer) {
                return;
            }
            var data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
            }
            tracer.log("Received request '" + message.method + " - (" + message.id + ")'.", data);
        }
        function traceReceivedNotification(message) {
            if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
                return;
            }
            var data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = "Params: " + JSON.stringify(message.params, null, 4) + "\n\n";
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log("Received notification '" + message.method + "'.", data);
        }
        function traceReceviedResponse(message, responsePromise) {
            if (trace === Trace.Off || !tracer) {
                return;
            }
            var data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = "Error data: " + JSON.stringify(message.error.data, null, 4) + "\n\n";
                }
                else {
                    if (message.result) {
                        data = "Result: " + JSON.stringify(message.result, null, 4) + "\n\n";
                    }
                    else if (is.undefined(message.error)) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                var error = message.error ? " Request failed: " + message.error.message + " (" + message.error.code + ")." : '';
                tracer.log("Received response '" + responsePromise.method + " - (" + message.id + ")' in " + (Date.now() - responsePromise.timerStart) + "ms." + error, data);
            }
            else {
                tracer.log("Received response " + message.id + " without active response promise.", data);
            }
        }
        var callback = function (message) {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isReponseMessage(message)) {
                handleResponse(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else {
                handleInvalidMessage(message);
            }
        };
        function throwIfClosedOrDisposed() {
            if (isClosed()) {
                throw new Error('Connection is closed.');
            }
            if (isDisposed()) {
                throw new Error('Connection is disposed.');
            }
        }
        function throwIfListening() {
            if (isListening()) {
                throw new Error('Connection is already listening');
            }
        }
        var connection = {
            sendNotification: function (type) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                throwIfClosedOrDisposed();
                var messageParams;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        messageParams = params[0];
                        break;
                    default:
                        messageParams = params;
                        break;
                }
                var notificatioMessage = {
                    jsonrpc: version,
                    method: is.string(type) ? type : type.method,
                    params: messageParams
                };
                traceSendNotification(notificatioMessage);
                messageWriter.write(notificatioMessage);
            },
            onNotification: function (type, handler) {
                throwIfClosedOrDisposed();
                notificationHandlers[is.string(type) ? type : type.method] = handler;
            },
            sendRequest: function (type) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                throwIfClosedOrDisposed();
                var method = is.string(type) ? type : type.method;
                var messageParams;
                var token = undefined;
                switch (params.length) {
                    case 0:
                        messageParams = null;
                        break;
                    case 1:
                        if (cancellation_1.CancellationToken.is(params[0])) {
                            messageParams = null;
                            token = params[0];
                        }
                        else {
                            messageParams = params[0];
                        }
                        break;
                    default:
                        var last = params.length - 1;
                        if (cancellation_1.CancellationToken.is(params[last])) {
                            token = params[last];
                            if (params.length === 2) {
                                messageParams = params[0];
                            }
                            else {
                                messageParams = params.slice(0, last);
                            }
                        }
                        else {
                            messageParams = params;
                        }
                        break;
                }
                var id = sequenceNumber++;
                var result = new Promise(function (resolve, reject) {
                    var requestMessage = {
                        jsonrpc: version,
                        id: id,
                        method: method,
                        params: messageParams
                    };
                    var responsePromise = { method: method, timerStart: Date.now(), resolve: resolve, reject: reject };
                    traceSendingRequest(requestMessage);
                    try {
                        messageWriter.write(requestMessage);
                    }
                    catch (e) {
                        // Writing the message failed. So we need to reject the promise.
                        responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                        responsePromise = null;
                    }
                    if (responsePromise) {
                        responsePromises[String(id)] = responsePromise;
                    }
                });
                if (token) {
                    token.onCancellationRequested(function () {
                        connection.sendNotification(CancelNotification.type, { id: id });
                    });
                }
                return result;
            },
            onRequest: function (type, handler) {
                throwIfClosedOrDisposed();
                requestHandlers[is.string(type) ? type : type.method] = handler;
            },
            trace: function (_value, _tracer, sendNotification) {
                if (sendNotification === void 0) { sendNotification = false; }
                trace = _value;
                if (trace === Trace.Off) {
                    tracer = undefined;
                }
                else {
                    tracer = _tracer;
                }
                if (sendNotification && !isClosed() && !isDisposed()) {
                    connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
                }
            },
            onError: errorEmitter.event,
            onClose: closeEmitter.event,
            onUnhandledNotification: unhandledNotificationEmitter.event,
            onDispose: disposeEmitter.event,
            dispose: function () {
                if (isDisposed()) {
                    return;
                }
                state = ConnectionState.Disposed;
                disposeEmitter.fire(undefined);
                var error = new Error('Connection got disposed.');
                Object.keys(responsePromises).forEach(function (key) {
                    responsePromises[key].reject(error);
                });
                responsePromises = Object.create(null);
                requestTokens = Object.create(null);
            },
            listen: function () {
                throwIfClosedOrDisposed();
                throwIfListening();
                state = ConnectionState.Listening;
                messageReader.listen(callback);
            }
        };
        connection.onNotification(LogTraceNotification.type, function (params) {
            if (trace === Trace.Off || !tracer) {
                return;
            }
            tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
        });
        return connection;
    }
    function isMessageReader(value) {
        return is.defined(value.listen) && is.undefined(value.read);
    }
    function isMessageWriter(value) {
        return is.defined(value.write) && is.undefined(value.end);
    }
    function createMessageConnection(input, output, logger) {
        var reader = isMessageReader(input) ? input : new messageReader_1.StreamMessageReader(input);
        var writer = isMessageWriter(output) ? output : new messageWriter_1.StreamMessageWriter(output);
        return _createMessageConnection(reader, writer, logger);
    }
    exports.createMessageConnection = createMessageConnection;
});
//# sourceMappingURL=main.js.map