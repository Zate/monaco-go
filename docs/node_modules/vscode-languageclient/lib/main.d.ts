/// <reference types="node" />
declare module "protocol" {
    import { RequestType, RequestType0, NotificationType, NotificationType0 } from 'vscode-jsonrpc';
    import { TextDocumentContentChangeEvent, Position, Range, Location, Diagnostic, Command, TextEdit, WorkspaceEdit, WorkspaceSymbolParams, TextDocumentIdentifier, VersionedTextDocumentIdentifier, TextDocumentItem, CompletionItem, CompletionList, Hover, SignatureHelp, Definition, ReferenceContext, DocumentHighlight, DocumentSymbolParams, SymbolInformation, CodeLens, CodeActionContext, FormattingOptions, DocumentLink } from 'vscode-languageserver-types';
    export interface DocumentFilter {
        /**
         * A language id, like `typescript`.
         */
        language?: string;
        /**
         * A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
         */
        scheme?: string;
        /**
         * A glob pattern, like `*.{ts,js}`.
         */
        pattern?: string;
    }
    /**
     * A language selector is the combination of one or many language identifiers
     * and [language filters](#DocumentFilter).
     *
     * @sample `let sel:DocumentSelector = 'typescript'`;
     * @sample `let sel:DocumentSelector = ['typescript', { language: 'json', pattern: '**âˆ•tsconfig.json' }]`;
     */
    export type DocumentSelector = string | DocumentFilter | (string | DocumentFilter)[];
    /**
     * General paramters to to regsiter for an notification or to register a provider.
     */
    export interface Registration {
        /**
         * The id used to register the request. The id can be used to deregister
         * the request again.
         */
        id: string;
        /**
         * The method to register for.
         */
        method: string;
        /**
         * Options necessary for the registration.
         */
        registerOptions: DocumentOptions;
    }
    export interface RegistrationParams {
        registrations: Registration[];
    }
    /**
     * Register the given request or notification on the other side. Since requests can be sent from the client
     * to the server and vice versa this request can be sent into both directions.
     */
    export namespace RegistrationRequest {
        const type: RequestType<RegistrationParams, void, void, void>;
    }
    /**
     * General parameters to unregister a request or notification.
     */
    export interface Unregistration {
        /**
         * The id used to unregister the request or notification. Usually an id
         * provided during the register request.
         */
        id: string;
        /**
         * The method to unregister for.
         */
        method: string;
    }
    export interface UnregistrationParams {
        unregisterations: Unregistration[];
    }
    /**
     * Unregisters the given request on the other side.
     */
    export namespace UnregistrationRequest {
        const type: RequestType<UnregistrationParams, void, void, void>;
    }
    /**
     * A parameter literal used in requests to pass a text document and a position inside that
     * document.
     */
    export interface TextDocumentPositionParams {
        /**
         * The text document.
         */
        textDocument: TextDocumentIdentifier;
        /**
         * The position inside the text document.
         */
        position: Position;
    }
    /**
     * Workspace specific client capabilities.
     */
    export interface WorkspaceClientCapabilites {
        /**
         * The client supports applying batch edits
         * to the workspace.
         */
        applyEdit?: boolean;
    }
    /**
     * Text document specific client capabilities.
     */
    export interface TextDocumentClientCapabilities {
        /**
         * The client supports sending will save notifications.
         */
        willSaveNotification?: boolean;
        /**
         * The client supports sending a will save request and
         * waits for a response providing text edits which will
         * be applied to the document before it is saved.
         */
        willSaveWaitUntilRequest?: boolean;
    }
    /**
     * Defines the capabilities provided by the client.
     */
    export interface ClientCapabilities {
        /**
         * The client supports dynamic feature registration.
         */
        dynamicRegistration?: boolean;
        /**
         * Workspace specific client capabilities.
         */
        workspace?: WorkspaceClientCapabilites;
        /**
         * Text document specific client capabilities.
         */
        textDocument?: TextDocumentClientCapabilities;
        /**
         * Experimental client capabilities.
         */
        experimental?: any;
    }
    /**
     * Defines how the host (editor) should sync
     * document changes to the language server.
     */
    export enum TextDocumentSyncKind {
        /**
         * Documents should not be synced at all.
         */
        None = 0,
        /**
         * Documents are synced by always sending the full content
         * of the document.
         */
        Full = 1,
        /**
         * Documents are synced by sending the full content on open.
         * After that only incremental updates to the document are
         * send.
         */
        Incremental = 2,
    }
    export interface DocumentOptions {
        /**
         * An optional document selector to identify the scope of the registration. If not
         * provided the registration happens for the scope determined by the other side.
         */
        documentSelector?: DocumentSelector;
    }
    /**
     * Save options.
     */
    export interface SaveOptions extends DocumentOptions {
        /**
         * The client is supposed to include the content on save.
         */
        includeContent?: boolean;
    }
    /**
     * Completion options.
     */
    export interface CompletionOptions extends DocumentOptions {
        /**
         * The characters that trigger completion automatically.
         */
        triggerCharacters?: string[];
        /**
         * The server provides support to resolve additional
         * information for a completion item.
         */
        resolveProvider?: boolean;
    }
    /**
     * Signature help options.
     */
    export interface SignatureHelpOptions extends DocumentOptions {
        /**
         * The characters that trigger signature help
         * automatically.
         */
        triggerCharacters?: string[];
    }
    /**
     * Code Lens options.
     */
    export interface CodeLensOptions extends DocumentOptions {
        /**
         * Code lens has a resolve provider as well.
         */
        resolveProvider?: boolean;
    }
    /**
     * Format document on type options
     */
    export interface DocumentOnTypeFormattingOptions extends DocumentOptions {
        /**
         * A character on which formatting should be triggered, like `}`.
         */
        firstTriggerCharacter: string;
        /**
         * More trigger characters.
         */
        moreTriggerCharacter?: string[];
    }
    /**
     * Document link options
     */
    export interface DocumentLinkOptions extends DocumentOptions {
        /**
         * Document links have a resolve provider as well.
         */
        resolveProvider?: boolean;
    }
    /**
     * Defines the capabilities provided by a language
     * server.
     */
    export interface ServerCapabilities {
        /**
         * Defines how text documents are synced.
         */
        textDocumentSync?: number;
        /**
         * The server provides hover support.
         */
        hoverProvider?: boolean;
        /**
         * The server provides completion support.
         */
        completionProvider?: CompletionOptions;
        /**
         * The server provides signature help support.
         */
        signatureHelpProvider?: SignatureHelpOptions;
        /**
         * The server provides goto definition support.
         */
        definitionProvider?: boolean;
        /**
         * The server provides find references support.
         */
        referencesProvider?: boolean;
        /**
         * The server provides document highlight support.
         */
        documentHighlightProvider?: boolean;
        /**
         * The server provides document symbol support.
         */
        documentSymbolProvider?: boolean;
        /**
         * The server provides workspace symbol support.
         */
        workspaceSymbolProvider?: boolean;
        /**
         * The server provides code actions.
         */
        codeActionProvider?: boolean;
        /**
         * The server provides code lens.
         */
        codeLensProvider?: CodeLensOptions;
        /**
         * The server provides document formatting.
         */
        documentFormattingProvider?: boolean;
        /**
         * The server provides document range formatting.
         */
        documentRangeFormattingProvider?: boolean;
        /**
         * The server provides document formatting on typing.
         */
        documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions;
        /**
         * The server provides rename support.
         */
        renameProvider?: boolean;
        /**
         * The server provides document link support.
         */
        documentLinkProvider?: DocumentLinkOptions;
        /**
         * The server provides execute command support.
         */
        executeCommandProvider?: ExecuteCommandOptions;
    }
    /**
     * The initialize request is sent from the client to the server.
     * It is sent once as the request after starting up the server.
     * The requests parameter is of type [InitializeParams](#InitializeParams)
     * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
     * resolves to such.
     */
    export namespace InitializeRequest {
        const type: RequestType<InitializeParams, InitializeResult, InitializeError, void>;
    }
    /**
     * The initialize parameters
     */
    export interface InitializeParams {
        /**
         * The process Id of the parent process that started
         * the server.
         */
        processId: number;
        /**
         * The rootPath of the workspace. Is null
         * if no folder is open.
         */
        rootPath: string | null;
        /**
         * The capabilities provided by the client (editor)
         */
        capabilities: ClientCapabilities;
        /**
         * User provided initialization options.
         */
        initializationOptions?: any;
        /**
         * The initial trace setting. If omitted trace is disabled ('off').
         */
        trace?: 'off' | 'messages' | 'verbose';
    }
    /**
     * The result returned from an initilize request.
     */
    export interface InitializeResult {
        /**
         * The capabilities the language server provides.
         */
        capabilities: ServerCapabilities;
    }
    /**
     * The data type of the ResponseError if the
     * initialize request fails.
     */
    export interface InitializeError {
        /**
         * Indicates whether the client should retry to send the
         * initialize request after showing the message provided
         * in the {@link ResponseError}
         */
        retry: boolean;
    }
    export interface InitializedParams {
    }
    /**
     * The intialized notification is send from the client to the
     * server after the client is fully initialized and the server
     * is allowed to send requests from the server to the client.
     */
    export namespace InitializedNotification {
        const type: NotificationType<InitializedParams, void>;
    }
    /**
     * A shutdown request is sent from the client to the server.
     * It is sent once when the client descides to shutdown the
     * server. The only notification that is sent after a shudown request
     * is the exit event.
     */
    export namespace ShutdownRequest {
        const type: RequestType0<void, void, void>;
    }
    /**
     * The exit event is sent from the client to the server to
     * ask the server to exit its process.
     */
    export namespace ExitNotification {
        const type: NotificationType0<void>;
    }
    /**
     * The configuration change notification is sent from the client to the server
     * when the client's configuration has changed. The notification contains
     * the changed configuration as defined by the language client.
     */
    export namespace DidChangeConfigurationNotification {
        const type: NotificationType<DidChangeConfigurationParams, void>;
    }
    /**
     * The parameters of a change configuration notification.
     */
    export interface DidChangeConfigurationParams {
        /**
         * The actual changed settings
         */
        settings: any;
    }
    /**
     * The message type
     */
    export enum MessageType {
        /**
         * An error message.
         */
        Error = 1,
        /**
         * A warning message.
         */
        Warning = 2,
        /**
         * An information message.
         */
        Info = 3,
        /**
         * A log message.
         */
        Log = 4,
    }
    /**
     * The parameters of a notification message.
     */
    export interface ShowMessageParams {
        /**
         * The message type. See {@link MessageType}
         */
        type: number;
        /**
         * The actual message
         */
        message: string;
    }
    /**
     * The show message notification is sent from a server to a client to ask
     * the client to display a particular message in the user interface.
     */
    export namespace ShowMessageNotification {
        const type: NotificationType<ShowMessageParams, void>;
    }
    export interface MessageActionItem {
        /**
         * A short title like 'Retry', 'Open Log' etc.
         */
        title: string;
    }
    export interface ShowMessageRequestParams {
        /**
         * The message type. See {@link MessageType}
         */
        type: number;
        /**
         * The actual message
         */
        message: string;
        /**
         * The message action items to present.
         */
        actions?: MessageActionItem[];
    }
    /**
     * The show message request is sent from the server to the clinet to show a message
     * and a set of options actions to the user.
     */
    export namespace ShowMessageRequest {
        const type: RequestType<ShowMessageRequestParams, MessageActionItem, void, void>;
    }
    /**
     * The log message notification is sent from the server to the client to ask
     * the client to log a particular message.
     */
    export namespace LogMessageNotification {
        let type: NotificationType<LogMessageParams, void>;
    }
    /**
     * The log message parameters.
     */
    export interface LogMessageParams {
        /**
         * The message type. See {@link MessageType}
         */
        type: number;
        /**
         * The actual message
         */
        message: string;
    }
    /**
     * The telemetry event notification is sent from the server to the client to ask
     * the client to log telemetry data.
     */
    export namespace TelemetryEventNotification {
        let type: NotificationType<any, void>;
    }
    /**
     * The parameters send in a open text document notification
     */
    export interface DidOpenTextDocumentParams {
        /**
         * The document that was opened.
         */
        textDocument: TextDocumentItem;
    }
    /**
     * The document open notification is sent from the client to the server to signal
     * newly opened text documents. The document's truth is now managed by the client
     * and the server must not try to read the document's truth using the document's
     * uri.
     */
    export namespace DidOpenTextDocumentNotification {
        const type: NotificationType<DidOpenTextDocumentParams, DocumentOptions>;
    }
    /**
     * The change text document notification's parameters.
     */
    export interface DidChangeTextDocumentParams {
        /**
         * The document that did change. The version number points
         * to the version after all provided content changes have
         * been applied.
         */
        textDocument: VersionedTextDocumentIdentifier;
        /**
         * The actual content changes.
         */
        contentChanges: TextDocumentContentChangeEvent[];
    }
    /**
     * Descibe options to be used when registered for text document change events.
     */
    export interface DidChangeTextDocumentOptions extends DocumentOptions {
        /**
         * How documents are synced to the server.
         */
        syncKind: number;
    }
    /**
     * The document change notification is sent from the client to the server to signal
     * changes to a text document.
     */
    export namespace DidChangeTextDocumentNotification {
        const type: NotificationType<DidChangeTextDocumentParams, DidChangeTextDocumentOptions>;
    }
    /**
     * The parameters send in a close text document notification
     */
    export interface DidCloseTextDocumentParams {
        /**
         * The document that was closed.
         */
        textDocument: TextDocumentIdentifier;
    }
    /**
     * The document close notification is sent from the client to the server when
     * the document got closed in the client. The document's truth now exists
     * where the document's uri points to (e.g. if the document's uri is a file uri
     * the truth now exists on disk).
     */
    export namespace DidCloseTextDocumentNotification {
        const type: NotificationType<DidCloseTextDocumentParams, DocumentOptions>;
    }
    /**
     * The parameters send in a save text document notification
     */
    export interface DidSaveTextDocumentParams {
        /**
         * The document that was closed.
         */
        textDocument: VersionedTextDocumentIdentifier;
        /**
         * Optional the content when saved
         */
        content?: string;
    }
    /**
     * The document save notification is sent from the client to the server when
     * the document got saved in the client.
     */
    export namespace DidSaveTextDocumentNotification {
        const type: NotificationType<DidSaveTextDocumentParams, SaveOptions>;
    }
    /**
     * The parameters send in a will save text document notification.
     */
    export interface WillSaveTextDocumentParams {
        /**
         * The document that will be saved.
         */
        textDocument: TextDocumentIdentifier;
        /**
         * The 'TextDocumentSaveReason'.
         */
        reason: number;
    }
    /**
     * A document will save notification is sent from the client to the server before
     * the document is actually saved.
     */
    export namespace WillSaveTextDocumentNotification {
        const type: NotificationType<WillSaveTextDocumentParams, DocumentOptions>;
    }
    /**
     * A document will save request is sent from the client to the server before
     * the document is actually saved. The request can return an array of TextEdits
     * which will be applied to the text document before it is saved. Please note that
     * clients might drop results if computing the text edits took too long or if a
     * server constantly fails on this request. This is done to keep the save fast and
     * reliable.
     */
    export namespace WillSaveTextDocumentWaitUntilRequest {
        const type: RequestType<WillSaveTextDocumentParams, TextEdit[], void, DocumentOptions>;
    }
    /**
     * The watched files notification is sent from the client to the server when
     * the client detects changes to file watched by the lanaguage client.
     */
    export namespace DidChangeWatchedFilesNotification {
        const type: NotificationType<DidChangeWatchedFilesParams, void>;
    }
    /**
     * The watched files change notification's parameters.
     */
    export interface DidChangeWatchedFilesParams {
        /**
         * The actual file events.
         */
        changes: FileEvent[];
    }
    /**
     * The file event type
     */
    export enum FileChangeType {
        /**
         * The file got created.
         */
        Created = 1,
        /**
         * The file got changed.
         */
        Changed = 2,
        /**
         * The file got deleted.
         */
        Deleted = 3,
    }
    /**
     * An event describing a file change.
     */
    export interface FileEvent {
        /**
         * The file's uri.
         */
        uri: string;
        /**
         * The change type.
         */
        type: number;
    }
    /**
     * Diagnostics notification are sent from the server to the client to signal
     * results of validation runs.
     */
    export namespace PublishDiagnosticsNotification {
        const type: NotificationType<PublishDiagnosticsParams, void>;
    }
    /**
     * The publish diagnostic notification's parameters.
     */
    export interface PublishDiagnosticsParams {
        /**
         * The URI for which diagnostic information is reported.
         */
        uri: string;
        /**
         * An array of diagnostic information items.
         */
        diagnostics: Diagnostic[];
    }
    /**
     * Request to request completion at a given text document position. The request's
     * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
     * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
     * or a Thenable that resolves to such.
     */
    export namespace CompletionRequest {
        const type: RequestType<TextDocumentPositionParams, CompletionItem[] | CompletionList, void, CompletionOptions>;
    }
    /**
     * Request to resolve additional information for a given completion item.The request's
     * parameter is of type [CompletionItem](#CompletionItem) the response
     * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
     */
    export namespace CompletionResolveRequest {
        const type: RequestType<CompletionItem, CompletionItem, void, void>;
    }
    /**
     * Request to request hover information at a given text document position. The request's
     * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
     * type [Hover](#Hover) or a Thenable that resolves to such.
     */
    export namespace HoverRequest {
        const type: RequestType<TextDocumentPositionParams, Hover, void, DocumentOptions>;
    }
    export namespace SignatureHelpRequest {
        const type: RequestType<TextDocumentPositionParams, SignatureHelp, void, SignatureHelpOptions>;
    }
    /**
     * A request to resolve the defintion location of a symbol at a given text
     * document position. The request's parameter is of type [TextDocumentPosition]
     * (#TextDocumentPosition) the response is of type [Definition](#Definition) or a
     * Thenable that resolves to such.
     */
    export namespace DefinitionRequest {
        const type: RequestType<TextDocumentPositionParams, Definition, void, DocumentOptions>;
    }
    /**
     * Parameters for a [ReferencesRequest](#ReferencesRequest).
     */
    export interface ReferenceParams extends TextDocumentPositionParams {
        context: ReferenceContext;
    }
    /**
     * A request to resolve project-wide references for the symbol denoted
     * by the given text document position. The request's parameter is of
     * type [ReferenceParams](#ReferenceParams) the response is of type
     * [Location[]](#Location) or a Thenable that resolves to such.
     */
    export namespace ReferencesRequest {
        const type: RequestType<ReferenceParams, Location[], void, DocumentOptions>;
    }
    /**
     * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
     * text document position. The request's parameter is of type [TextDocumentPosition]
     * (#TextDocumentPosition) the request reponse is of type [DocumentHighlight[]]
     * (#DocumentHighlight) or a Thenable that resolves to such.
     */
    export namespace DocumentHighlightRequest {
        const type: RequestType<TextDocumentPositionParams, DocumentHighlight[], void, DocumentOptions>;
    }
    /**
     * A request to list all symbols found in a given text document. The request's
     * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
     * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
     * that resolves to such.
     */
    export namespace DocumentSymbolRequest {
        const type: RequestType<DocumentSymbolParams, SymbolInformation[], void, DocumentOptions>;
    }
    /**
     * A request to list project-wide symbols matching the query string given
     * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
     * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
     * resolves to such.
     */
    export namespace WorkspaceSymbolRequest {
        const type: RequestType<WorkspaceSymbolParams, SymbolInformation[], void, void>;
    }
    /**
     * Params for the CodeActionRequest
     */
    export interface CodeActionParams {
        /**
         * The document in which the command was invoked.
         */
        textDocument: TextDocumentIdentifier;
        /**
         * The range for which the command was invoked.
         */
        range: Range;
        /**
         * Context carrying additional information.
         */
        context: CodeActionContext;
    }
    /**
     * A request to provide commands for the given text document and range.
     */
    export namespace CodeActionRequest {
        const type: RequestType<CodeActionParams, Command[], void, DocumentOptions>;
    }
    /**
     * Params for the Code Lens request.
     */
    export interface CodeLensParams {
        /**
         * The document to request code lens for.
         */
        textDocument: TextDocumentIdentifier;
    }
    /**
     * A request to provide code lens for the given text document.
     */
    export namespace CodeLensRequest {
        const type: RequestType<CodeLensParams, CodeLens[], void, CodeLensOptions>;
    }
    /**
     * A request to resolve a command for a given code lens.
     */
    export namespace CodeLensResolveRequest {
        const type: RequestType<CodeLens, CodeLens, void, void>;
    }
    export interface DocumentFormattingParams {
        /**
         * The document to format.
         */
        textDocument: TextDocumentIdentifier;
        /**
         * The format options
         */
        options: FormattingOptions;
    }
    /**
     * A request to to format a whole document.
     */
    export namespace DocumentFormattingRequest {
        const type: RequestType<DocumentFormattingParams, TextEdit[], void, DocumentOptions>;
    }
    export interface DocumentRangeFormattingParams {
        /**
         * The document to format.
         */
        textDocument: TextDocumentIdentifier;
        /**
         * The range to format
         */
        range: Range;
        /**
         * The format options
         */
        options: FormattingOptions;
    }
    /**
     * A request to to format a range in a document.
     */
    export namespace DocumentRangeFormattingRequest {
        const type: RequestType<DocumentRangeFormattingParams, TextEdit[], void, DocumentOptions>;
    }
    export interface DocumentOnTypeFormattingParams {
        /**
         * The document to format.
         */
        textDocument: TextDocumentIdentifier;
        /**
         * The position at which this request was send.
         */
        position: Position;
        /**
         * The character that has been typed.
         */
        ch: string;
        /**
         * The format options.
         */
        options: FormattingOptions;
    }
    /**
     * A request to format a document on type.
     */
    export namespace DocumentOnTypeFormattingRequest {
        const type: RequestType<DocumentOnTypeFormattingParams, TextEdit[], void, DocumentOnTypeFormattingOptions>;
    }
    export interface RenameParams {
        /**
         * The document to format.
         */
        textDocument: TextDocumentIdentifier;
        /**
         * The position at which this request was send.
         */
        position: Position;
        /**
         * The new name of the symbol. If the given name is not valid the
         * request must return a [ResponseError](#ResponseError) with an
         * appropriate message set.
         */
        newName: string;
    }
    /**
     * A request to rename a symbol.
     */
    export namespace RenameRequest {
        const type: RequestType<RenameParams, WorkspaceEdit, void, DocumentOptions>;
    }
    export interface DocumentLinkParams {
        /**
         * The document to provide document links for.
         */
        textDocument: TextDocumentIdentifier;
    }
    /**
     * A request to provide document links
     */
    export namespace DocumentLinkRequest {
        const type: RequestType<DocumentLinkParams, DocumentLink[], void, DocumentLinkOptions>;
    }
    /**
     * Request to resolve additional information for a given document link. The request's
     * parameter is of type [DocumentLink](#DocumentLink) the response
     * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
     */
    export namespace DocumentLinkResolveRequest {
        const type: RequestType<DocumentLink, DocumentLink, void, void>;
    }
    export interface ExecuteCommandParams {
        /**
         * The identifier of the actual command handler.
         */
        command: string;
        /**
         * Arguments that the command should be invoked with.
         */
        arguments?: any[];
    }
    /**
     * Execute command response.
     */
    export interface ExecuteCommandResponse {
    }
    export interface ExecuteCommandOptions {
        /**
         * The commands to be executed on the server
         */
        commands: string[];
    }
    /**
     * A request send from the client to the server to execute a command. The request might return
     * a workspace edit which the client will apply to the workspace.
     */
    export namespace ExecuteCommandRequest {
        const type: RequestType<ExecuteCommandParams, ExecuteCommandResponse, void, ExecuteCommandOptions>;
    }
    /**
     * The parameters passed via a apply workspace edit request.
     */
    export interface ApplyWorkspaceEditParams {
        /**
         * The edits to apply.
         */
        edit: WorkspaceEdit;
    }
    /**
     * A reponse returned from the apply workspace edit request.
     */
    export interface ApplyWorkspaceEditResponse {
        /**
         * Indicates whether the edit was applied or not.
         */
        applied: boolean;
    }
    /**
     * A request sent from the server to the client to modified certain files.
     */
    export namespace ApplyWorkspaceEditRequest {
        const type: RequestType<ApplyWorkspaceEditParams, ApplyWorkspaceEditResponse, void, void>;
    }
}
declare module "utils/is" {
    export function boolean(value: any): value is boolean;
    export function string(value: any): value is string;
    export function number(value: any): value is number;
    export function error(value: any): value is Error;
    export function func(value: any): value is Function;
    export function array<T>(value: any): value is T[];
    export function stringArray(value: any): value is string[];
    export function typedArray<T>(value: any, check: (value: any) => boolean): value is T[];
    export function thenable<T>(value: any): value is Thenable<T>;
}
declare module "protocolCompletionItem" {
    import * as code from 'vscode';
    export default class ProtocolCompletionItem extends code.CompletionItem {
        data: any;
        constructor(label: string);
    }
}
declare module "protocolCodeLens" {
    import * as code from 'vscode';
    export default class ProtocolCodeLens extends code.CodeLens {
        data: any;
        constructor(range: code.Range);
    }
}
declare module "codeConverter" {
    import * as code from 'vscode';
    import * as types from 'vscode-languageserver-types';
    import * as proto from "protocol";
    export interface Converter {
        asUri(uri: code.Uri): string;
        asTextDocumentIdentifier(textDocument: code.TextDocument): types.TextDocumentIdentifier;
        asOpenTextDocumentParams(textDocument: code.TextDocument): proto.DidOpenTextDocumentParams;
        asChangeTextDocumentParams(textDocument: code.TextDocument): proto.DidChangeTextDocumentParams;
        asChangeTextDocumentParams(event: code.TextDocumentChangeEvent): proto.DidChangeTextDocumentParams;
        asCloseTextDocumentParams(textDocument: code.TextDocument): proto.DidCloseTextDocumentParams;
        asSaveTextDocumentParams(textDocument: code.TextDocument, includeContent?: boolean): proto.DidSaveTextDocumentParams;
        asWillSaveTextDocumentParams(event: code.TextDocumentWillSaveEvent): proto.WillSaveTextDocumentParams;
        asTextDocumentPositionParams(textDocument: code.TextDocument, position: code.Position): proto.TextDocumentPositionParams;
        asWorkerPosition(position: code.Position): types.Position;
        asPosition(value: code.Position): types.Position;
        asPosition(value: undefined): undefined;
        asPosition(value: null): null;
        asPosition(value: code.Position | undefined | null): types.Position | undefined | null;
        asRange(value: code.Range): types.Range;
        asRange(value: undefined): undefined;
        asRange(value: null): null;
        asRange(value: code.Range | undefined | null): types.Range | undefined | null;
        asDiagnosticSeverity(value: code.DiagnosticSeverity): types.DiagnosticSeverity;
        asDiagnostic(item: code.Diagnostic): types.Diagnostic;
        asDiagnostics(items: code.Diagnostic[]): types.Diagnostic[];
        asCompletionItem(item: code.CompletionItem): types.CompletionItem;
        asTextEdit(edit: code.TextEdit): types.TextEdit;
        asReferenceParams(textDocument: code.TextDocument, position: code.Position, options: {
            includeDeclaration: boolean;
        }): proto.ReferenceParams;
        asCodeActionContext(context: code.CodeActionContext): types.CodeActionContext;
        asCommand(item: code.Command): types.Command;
        asCodeLens(item: code.CodeLens): types.CodeLens;
        asFormattingOptions(item: code.FormattingOptions): types.FormattingOptions;
        asDocumentSymbolParams(textDocument: code.TextDocument): types.DocumentSymbolParams;
        asCodeLensParams(textDocument: code.TextDocument): proto.CodeLensParams;
        asDocumentLink(item: code.DocumentLink): types.DocumentLink;
        asDocumentLinkParams(textDocument: code.TextDocument): proto.DocumentLinkParams;
    }
    export interface URIConverter {
        (value: code.Uri): string;
    }
    export function createConverter(uriConverter?: URIConverter): Converter;
}
declare module "protocolConverter" {
    import * as code from 'vscode';
    import * as ls from 'vscode-languageserver-types';
    import ProtocolCompletionItem from "protocolCompletionItem";
    export interface Converter {
        asUri(value: string): code.Uri;
        asDiagnostic(diagnostic: ls.Diagnostic): code.Diagnostic;
        asDiagnostics(diagnostics: ls.Diagnostic[]): code.Diagnostic[];
        asPosition(value: undefined | null): undefined;
        asPosition(value: ls.Position): code.Position;
        asPosition(value: ls.Position | undefined | null): code.Position | undefined;
        asRange(value: undefined | null): undefined;
        asRange(value: ls.Range): code.Range;
        asRange(value: ls.Range | undefined | null): code.Range | undefined;
        asDiagnosticSeverity(value: number | undefined | null): code.DiagnosticSeverity;
        asHover(hover: ls.Hover): code.Hover;
        asHover(hover: undefined | null): undefined;
        asHover(hover: ls.Hover | undefined | null): code.Hover | undefined;
        asCompletionResult(result: ls.CompletionItem[] | ls.CompletionList): code.CompletionItem[] | code.CompletionList;
        asCompletionResult(result: undefined | null): undefined;
        asCompletionResult(result: ls.CompletionItem[] | ls.CompletionList | undefined | null): code.CompletionItem[] | code.CompletionList | undefined;
        asCompletionItem(item: ls.CompletionItem): ProtocolCompletionItem;
        asTextEdit(edit: ls.TextEdit): code.TextEdit;
        asTextEdits(items: ls.TextEdit[]): code.TextEdit[];
        asTextEdits(items: undefined | null): undefined;
        asTextEdits(items: ls.TextEdit[] | undefined | null): code.TextEdit[] | undefined;
        asSignatureHelp(item: undefined | null): undefined;
        asSignatureHelp(item: ls.SignatureHelp): code.SignatureHelp;
        asSignatureHelp(item: ls.SignatureHelp | undefined | null): code.SignatureHelp | undefined;
        asSignatureInformation(item: ls.SignatureInformation): code.SignatureInformation;
        asSignatureInformations(items: ls.SignatureInformation[]): code.SignatureInformation[];
        asParameterInformation(item: ls.ParameterInformation): code.ParameterInformation;
        asParameterInformations(item: ls.ParameterInformation[]): code.ParameterInformation[];
        asDefinitionResult(item: ls.Definition): code.Definition;
        asDefinitionResult(item: undefined | null): undefined;
        asDefinitionResult(item: ls.Definition | undefined | null): code.Definition | undefined;
        asLocation(item: ls.Location): code.Location;
        asLocation(item: undefined | null): undefined;
        asLocation(item: ls.Location | undefined | null): code.Location | undefined;
        asReferences(values: ls.Location[]): code.Location[];
        asReferences(values: undefined | null): code.Location[] | undefined;
        asReferences(values: ls.Location[] | undefined | null): code.Location[] | undefined;
        asDocumentHighlightKind(item: ls.DocumentHighlightKind): code.DocumentHighlightKind;
        asDocumentHighlight(item: ls.DocumentHighlight): code.DocumentHighlight;
        asDocumentHighlights(values: ls.DocumentHighlight[]): code.DocumentHighlight[];
        asDocumentHighlights(values: undefined | null): undefined;
        asDocumentHighlights(values: ls.DocumentHighlight[] | undefined | null): code.DocumentHighlight[] | undefined;
        asSymbolInformation(item: ls.SymbolInformation, uri?: code.Uri): code.SymbolInformation;
        asSymbolInformations(values: ls.SymbolInformation[], uri?: code.Uri): code.SymbolInformation[];
        asSymbolInformations(values: undefined | null, uri?: code.Uri): undefined;
        asSymbolInformations(values: ls.SymbolInformation[] | undefined | null, uri?: code.Uri): code.SymbolInformation[] | undefined;
        asCommand(item: ls.Command): code.Command;
        asCommands(items: ls.Command[]): code.Command[];
        asCommands(items: undefined | null): undefined;
        asCommands(items: ls.Command[] | undefined | null): code.Command[] | undefined;
        asCodeLens(item: ls.CodeLens): code.CodeLens;
        asCodeLens(item: undefined | null): undefined;
        asCodeLens(item: ls.CodeLens | undefined | null): code.CodeLens | undefined;
        asCodeLenses(items: ls.CodeLens[]): code.CodeLens[];
        asCodeLenses(items: undefined | null): undefined;
        asCodeLenses(items: ls.CodeLens[] | undefined | null): code.CodeLens[] | undefined;
        asWorkspaceEdit(item: ls.WorkspaceEdit): code.WorkspaceEdit;
        asWorkspaceEdit(item: undefined | null): undefined;
        asWorkspaceEdit(item: ls.WorkspaceEdit | undefined | null): code.WorkspaceEdit | undefined;
        asDocumentLink(item: ls.DocumentLink): code.DocumentLink;
        asDocumentLinks(items: ls.DocumentLink[]): code.DocumentLink[];
        asDocumentLinks(items: undefined | null): undefined;
        asDocumentLinks(items: ls.DocumentLink[] | undefined | null): code.DocumentLink[] | undefined;
    }
    export interface URIConverter {
        (value: string): code.Uri;
    }
    export function createConverter(uriConverter?: URIConverter): Converter;
}
interface Thenable<T> extends PromiseLike<T> {
}
declare module "utils/async" {
    export interface ITask<T> {
        (): T;
    }
    export class Delayer<T> {
        defaultDelay: number;
        private timeout;
        private completionPromise;
        private onSuccess;
        private task;
        constructor(defaultDelay: number);
        trigger(task: ITask<T>, delay?: number): Promise<T>;
        forceDelivery(): T | undefined;
        isTriggered(): boolean;
        cancel(): void;
        private cancelTimeout();
    }
}
declare module "utils/electron" {
    import cp = require('child_process');
    export interface IForkOptions {
        cwd?: string;
        env?: any;
        encoding?: string;
        execArgv?: string[];
    }
    export function fork(modulePath: string, args: string[], options: IForkOptions, callback: (error: any, cp: cp.ChildProcess | undefined) => void): void;
}
declare var net: any, fs: any, stream: any, util: any;
declare var ENABLE_LOGGING: boolean;
declare var log: (str: string) => void;
declare var stdInPipeName: any;
declare var stdOutPipeName: any;
declare module "utils/processes" {
    import * as cp from 'child_process';
    import ChildProcess = cp.ChildProcess;
    export function terminate(process: ChildProcess, cwd?: string): boolean;
}
declare module "utils/uuid" {
    /**
     * Represents a UUID as defined by rfc4122.
     */
    export interface UUID {
        /**
         * @returns the canonical representation in sets of hexadecimal numbers separated by dashes.
         */
        asHex(): string;
        equals(other: UUID): boolean;
    }
    /**
     * An empty UUID that contains only zeros.
     */
    export const empty: UUID;
    export function v4(): UUID;
    export function isUUID(value: string): boolean;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    export function parse(value: string): UUID;
    export function generateUuid(): string;
}
declare module "vscode-languageclient" {
    import * as cp from 'child_process';
    import ChildProcess = cp.ChildProcess;
    import { TextDocument, Disposable, OutputChannel, FileSystemWatcher, DiagnosticCollection, CancellationToken } from 'vscode';
    import { Message, MessageType as RPCMessageType, ErrorCodes, ResponseError, RequestType, RequestType0, RequestHandler, RequestHandler0, GenericRequestHandler, NotificationType, NotificationType0, NotificationHandler, NotificationHandler0, GenericNotificationHandler, MessageReader, MessageWriter, Trace, Tracer, Event, Emitter, DataCallback, PartialMessageInfo } from 'vscode-jsonrpc';
    import { InitializeError, DocumentSelector, DocumentFilter, DidOpenTextDocumentParams } from "protocol";
    import * as c2p from "codeConverter";
    import * as p2c from "protocolConverter";
    export { Message, DataCallback, PartialMessageInfo, MessageReader, MessageWriter, Trace, Tracer, Event, Emitter };
    export { ResponseError, InitializeError, ErrorCodes, RequestType, RequestType0, RequestHandler, RequestHandler0, GenericRequestHandler, NotificationType, NotificationType0, NotificationHandler, NotificationHandler0, GenericNotificationHandler, DocumentSelector, DocumentFilter, DidOpenTextDocumentParams };
    export { Converter as Code2ProtocolConverter } from "codeConverter";
    export { Converter as Protocol2CodeConverter } from "protocolConverter";
    export * from 'vscode-languageserver-types';
    export interface StreamInfo {
        writer: NodeJS.WritableStream;
        reader: NodeJS.ReadableStream;
    }
    export interface ExecutableOptions {
        cwd?: string;
        stdio?: string | string[];
        env?: any;
        detached?: boolean;
    }
    export interface Executable {
        command: string;
        args?: string[];
        options?: ExecutableOptions;
    }
    export interface ForkOptions {
        cwd?: string;
        env?: any;
        encoding?: string;
        execArgv?: string[];
    }
    export enum TransportKind {
        stdio = 0,
        ipc = 1,
    }
    export interface NodeModule {
        module: string;
        transport?: TransportKind;
        args?: string[];
        runtime?: string;
        options?: ForkOptions;
    }
    export type ServerOptions = Executable | {
        run: Executable;
        debug: Executable;
    } | {
        run: NodeModule;
        debug: NodeModule;
    } | NodeModule | (() => Thenable<ChildProcess | StreamInfo>);
    /**
     * An action to be performed when the connection is producing errors.
     */
    export enum ErrorAction {
        /**
         * Continue running the server.
         */
        Continue = 1,
        /**
         * Shutdown the server.
         */
        Shutdown = 2,
    }
    /**
     * An action to be performed when the connection to a server got closed.
     */
    export enum CloseAction {
        /**
         * Don't restart the server. The connection stays closed.
         */
        DoNotRestart = 1,
        /**
         * Restart the server.
         */
        Restart = 2,
    }
    /**
     * A pluggable error handler that is invoked when the connection is either
     * producing errors or got closed.
     */
    export interface ErrorHandler {
        /**
         * An error has occurred while writing or reading from the connection.
         *
         * @param error - the error received
         * @param message - the message to be delivered to the server if know.
         * @param count - a count indicating how often an error is received. Will
         *  be reset if a message got successfully send or received.
         */
        error(error: Error, message: Message, count: number): ErrorAction;
        /**
         * The connection to the server got closed.
         */
        closed(): CloseAction;
    }
    export interface InitializationFailedHandler {
        (error: ResponseError<InitializeError> | Error | any): boolean;
    }
    export interface SynchronizeOptions {
        configurationSection?: string | string[];
        fileEvents?: FileSystemWatcher | FileSystemWatcher[];
    }
    export interface Configuration {
        willSaveTextDocumentWaitUntilRequest?: boolean | ((textDocument: TextDocument) => boolean);
    }
    export enum RevealOutputChannelOn {
        Info = 1,
        Warn = 2,
        Error = 3,
        Never = 4,
    }
    export interface LanguageClientOptions {
        configuration?: Configuration;
        documentSelector?: DocumentSelector;
        synchronize?: SynchronizeOptions;
        diagnosticCollectionName?: string;
        outputChannelName?: string;
        revealOutputChannelOn?: RevealOutputChannelOn;
        /**
         * The encoding use to read stdout and stderr. Defaults
         * to 'utf8' if ommitted.
         */
        stdioEncoding?: string;
        initializationOptions?: any | (() => any);
        initializationFailedHandler?: InitializationFailedHandler;
        errorHandler?: ErrorHandler;
        uriConverters?: {
            code2Protocol: c2p.URIConverter;
            protocol2Code: p2c.URIConverter;
        };
    }
    export enum State {
        Stopped = 1,
        Running = 2,
    }
    export interface StateChangeEvent {
        oldState: State;
        newState: State;
    }
    export class LanguageClient {
        private _id;
        private _name;
        private _serverOptions;
        private _clientOptions;
        private _forceDebug;
        private _state;
        private _onReady;
        private _onReadyCallbacks;
        private _connectionPromise;
        private _resolvedConnection;
        private _childProcess;
        private _outputChannel;
        private _capabilites;
        private _configuration;
        private _listeners;
        private _providers;
        private _diagnostics;
        private _fileEvents;
        private _fileEventDelayer;
        private _telemetryEmitter;
        private _stateChangeEmitter;
        private _trace;
        private _tracer;
        private _c2p;
        private _p2c;
        constructor(name: string, serverOptions: ServerOptions, clientOptions: LanguageClientOptions, forceDebug?: boolean);
        constructor(id: string, name: string, serverOptions: ServerOptions, clientOptions: LanguageClientOptions, forceDebug?: boolean);
        private state;
        private getPublicState();
        sendRequest<R, E, RO>(type: RequestType0<R, E, RO>, token?: CancellationToken): Thenable<R>;
        sendRequest<P, R, E, RO>(type: RequestType<P, R, E, RO>, params: P, token?: CancellationToken): Thenable<R>;
        sendRequest<R>(method: string, token?: CancellationToken): Thenable<R>;
        sendRequest<R>(method: string, param: any, token?: CancellationToken): Thenable<R>;
        onRequest<R, E, RO>(type: RequestType0<R, E, RO>, handler: RequestHandler0<R, E>): void;
        onRequest<P, R, E, RO>(type: RequestType<P, R, E, RO>, handler: RequestHandler<P, R, E>): void;
        onRequest<R, E>(method: string, handler: GenericRequestHandler<R, E>): void;
        sendNotification<RO>(type: NotificationType0<RO>): void;
        sendNotification<P, RO>(type: NotificationType<P, RO>, params?: P): void;
        sendNotification(method: string): void;
        sendNotification(method: string, params: any): void;
        onNotification<RO>(type: NotificationType0<RO>, handler: NotificationHandler0): void;
        onNotification<P, RO>(type: NotificationType<P, RO>, handler: NotificationHandler<P>): void;
        onNotification(method: string, handler: GenericNotificationHandler): void;
        readonly protocol2CodeConverter: p2c.Converter;
        readonly code2ProtocolConverter: c2p.Converter;
        readonly onTelemetry: Event<any>;
        readonly onDidChangeState: Event<StateChangeEvent>;
        readonly outputChannel: OutputChannel;
        readonly diagnostics: DiagnosticCollection | undefined;
        createDefaultErrorHandler(): ErrorHandler;
        trace: Trace;
        private data2String(data);
        info(message: string, data?: any): void;
        warn(message: string, data?: any): void;
        error(message: string, data?: any): void;
        private logTrace(message, data?);
        needsStart(): boolean;
        needsStop(): boolean;
        onReady(): Promise<void>;
        private isConnectionActive();
        start(): Disposable;
        private resolveConnection();
        private initialize(connection);
        stop(): Thenable<void>;
        private cleanUp(diagnostics?);
        private notifyFileEvent(event);
        private forceDocumentSync();
        private handleDiagnostics(params);
        private createConnection();
        private handleConnectionClosed();
        private handleConnectionError(error, message, count);
        private checkProcessDied(childProcess);
        private hookConfigurationChanged(connection);
        private refreshTrace(connection, sendNotification?);
        private onDidChangeConfiguration(connection);
        private extractSettingsInformation(keys);
        private hookFileEvents(_connection);
        private _registeredHandlers;
        private initRegistrationHandlers(_connection);
        private handleRegistrationRequest(params);
        private handleUnregistrationRequest(params);
        private handleApplyWorkspaceEdit(params);
        private hookCapabilities(_connection);
        protected logFailedRequest(type: RPCMessageType, error: any): void;
        private createCompletionProvider(options);
        private createHoverProvider(options);
        private createSignatureHelpProvider(options);
        private createDefinitionProvider(options);
        private createReferencesProvider(options);
        private createDocumentHighlightProvider(options);
        private createDocumentSymbolProvider(options);
        private createWorkspaceSymbolProvider(_options);
        private createCodeActionsProvider(options);
        private createCodeLensProvider(options);
        private createDocumentFormattingProvider(options);
        private createDocumentRangeFormattingProvider(options);
        private createDocumentOnTypeFormattingProvider(options);
        private createRenameProvider(options);
        private createDocumentLinkProvider(options);
    }
    export class SettingMonitor {
        private _client;
        private _setting;
        private _listeners;
        constructor(_client: LanguageClient, _setting: string);
        start(): Disposable;
        private onDidChangeConfiguration();
    }
}
