var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define("protocol", ["require", "exports"], function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    /**
     * Register the given request or notification on the other side. Since requests can be sent from the client
     * to the server and vice versa this request can be sent into both directions.
     */
    var RegistrationRequest;
    (function (RegistrationRequest) {
        RegistrationRequest.type = { get method() { return 'client/registrationRequest'; } };
    })(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
    /**
     * Unregisters the given request on the other side.
     */
    var UnregistrationRequest;
    (function (UnregistrationRequest) {
        UnregistrationRequest.type = { get method() { return 'client/unregistrationRequest'; } };
    })(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
    /**
     * Defines how the host (editor) should sync
     * document changes to the language server.
     */
    (function (TextDocumentSyncKind) {
        /**
         * Documents should not be synced at all.
         */
        TextDocumentSyncKind[TextDocumentSyncKind["None"] = 0] = "None";
        /**
         * Documents are synced by always sending the full content
         * of the document.
         */
        TextDocumentSyncKind[TextDocumentSyncKind["Full"] = 1] = "Full";
        /**
         * Documents are synced by sending the full content on open.
         * After that only incremental updates to the document are
         * send.
         */
        TextDocumentSyncKind[TextDocumentSyncKind["Incremental"] = 2] = "Incremental";
    })(exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
    var TextDocumentSyncKind = exports.TextDocumentSyncKind;
    /**
     * The initialize request is sent from the client to the server.
     * It is sent once as the request after starting up the server.
     * The requests parameter is of type [InitializeParams](#InitializeParams)
     * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
     * resolves to such.
     */
    var InitializeRequest;
    (function (InitializeRequest) {
        InitializeRequest.type = { get method() { return 'initialize'; } };
    })(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
    /**
     * The intialized notification is send from the client to the
     * server after the client is fully initialized and the server
     * is allowed to send requests from the server to the client.
     */
    var InitializedNotification;
    (function (InitializedNotification) {
        InitializedNotification.type = { get method() { return 'initialized'; } };
    })(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
    //---- Shutdown Method ----
    /**
     * A shutdown request is sent from the client to the server.
     * It is sent once when the client descides to shutdown the
     * server. The only notification that is sent after a shudown request
     * is the exit event.
     */
    var ShutdownRequest;
    (function (ShutdownRequest) {
        ShutdownRequest.type = { get method() { return 'shutdown'; } };
    })(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
    //---- Exit Notification ----
    /**
     * The exit event is sent from the client to the server to
     * ask the server to exit its process.
     */
    var ExitNotification;
    (function (ExitNotification) {
        ExitNotification.type = { get method() { return 'exit'; } };
    })(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
    //---- Configuration notification ----
    /**
     * The configuration change notification is sent from the client to the server
     * when the client's configuration has changed. The notification contains
     * the changed configuration as defined by the language client.
     */
    var DidChangeConfigurationNotification;
    (function (DidChangeConfigurationNotification) {
        DidChangeConfigurationNotification.type = { get method() { return 'workspace/didChangeConfiguration'; } };
    })(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
    //---- Message show and log notifications ----
    /**
     * The message type
     */
    (function (MessageType) {
        /**
         * An error message.
         */
        MessageType[MessageType["Error"] = 1] = "Error";
        /**
         * A warning message.
         */
        MessageType[MessageType["Warning"] = 2] = "Warning";
        /**
         * An information message.
         */
        MessageType[MessageType["Info"] = 3] = "Info";
        /**
         * A log message.
         */
        MessageType[MessageType["Log"] = 4] = "Log";
    })(exports.MessageType || (exports.MessageType = {}));
    var MessageType = exports.MessageType;
    /**
     * The show message notification is sent from a server to a client to ask
     * the client to display a particular message in the user interface.
     */
    var ShowMessageNotification;
    (function (ShowMessageNotification) {
        ShowMessageNotification.type = { get method() { return 'window/showMessage'; } };
    })(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
    /**
     * The show message request is sent from the server to the clinet to show a message
     * and a set of options actions to the user.
     */
    var ShowMessageRequest;
    (function (ShowMessageRequest) {
        ShowMessageRequest.type = { get method() { return 'window/showMessageRequest'; } };
    })(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
    /**
     * The log message notification is sent from the server to the client to ask
     * the client to log a particular message.
     */
    var LogMessageNotification;
    (function (LogMessageNotification) {
        LogMessageNotification.type = { get method() { return 'window/logMessage'; } };
    })(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
    //---- Telemetry notification
    /**
     * The telemetry event notification is sent from the server to the client to ask
     * the client to log telemetry data.
     */
    var TelemetryEventNotification;
    (function (TelemetryEventNotification) {
        TelemetryEventNotification.type = { get method() { return 'telemetry/event'; } };
    })(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
    /**
     * The document open notification is sent from the client to the server to signal
     * newly opened text documents. The document's truth is now managed by the client
     * and the server must not try to read the document's truth using the document's
     * uri.
     */
    var DidOpenTextDocumentNotification;
    (function (DidOpenTextDocumentNotification) {
        DidOpenTextDocumentNotification.type = { get method() { return 'textDocument/didOpen'; } };
    })(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
    /**
     * The document change notification is sent from the client to the server to signal
     * changes to a text document.
     */
    var DidChangeTextDocumentNotification;
    (function (DidChangeTextDocumentNotification) {
        DidChangeTextDocumentNotification.type = { get method() { return 'textDocument/didChange'; } };
    })(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
    /**
     * The document close notification is sent from the client to the server when
     * the document got closed in the client. The document's truth now exists
     * where the document's uri points to (e.g. if the document's uri is a file uri
     * the truth now exists on disk).
     */
    var DidCloseTextDocumentNotification;
    (function (DidCloseTextDocumentNotification) {
        DidCloseTextDocumentNotification.type = { get method() { return 'textDocument/didClose'; } };
    })(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
    /**
     * The document save notification is sent from the client to the server when
     * the document got saved in the client.
     */
    var DidSaveTextDocumentNotification;
    (function (DidSaveTextDocumentNotification) {
        DidSaveTextDocumentNotification.type = { get method() { return 'textDocument/didSave'; } };
    })(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
    /**
     * A document will save notification is sent from the client to the server before
     * the document is actually saved.
     */
    var WillSaveTextDocumentNotification;
    (function (WillSaveTextDocumentNotification) {
        WillSaveTextDocumentNotification.type = { get method() { return 'textDocument/willSave'; } };
    })(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
    /**
     * A document will save request is sent from the client to the server before
     * the document is actually saved. The request can return an array of TextEdits
     * which will be applied to the text document before it is saved. Please note that
     * clients might drop results if computing the text edits took too long or if a
     * server constantly fails on this request. This is done to keep the save fast and
     * reliable.
     */
    var WillSaveTextDocumentWaitUntilRequest;
    (function (WillSaveTextDocumentWaitUntilRequest) {
        WillSaveTextDocumentWaitUntilRequest.type = { get method() { return 'textDocument/willSaveWaitUntil'; } };
    })(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
    //---- File eventing ----
    /**
     * The watched files notification is sent from the client to the server when
     * the client detects changes to file watched by the lanaguage client.
     */
    var DidChangeWatchedFilesNotification;
    (function (DidChangeWatchedFilesNotification) {
        DidChangeWatchedFilesNotification.type = { get method() { return 'workspace/didChangeWatchedFiles'; } };
    })(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
    /**
     * The file event type
     */
    (function (FileChangeType) {
        /**
         * The file got created.
         */
        FileChangeType[FileChangeType["Created"] = 1] = "Created";
        /**
         * The file got changed.
         */
        FileChangeType[FileChangeType["Changed"] = 2] = "Changed";
        /**
         * The file got deleted.
         */
        FileChangeType[FileChangeType["Deleted"] = 3] = "Deleted";
    })(exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangeType = exports.FileChangeType;
    //---- Diagnostic notification ----
    /**
     * Diagnostics notification are sent from the server to the client to signal
     * results of validation runs.
     */
    var PublishDiagnosticsNotification;
    (function (PublishDiagnosticsNotification) {
        PublishDiagnosticsNotification.type = { get method() { return 'textDocument/publishDiagnostics'; } };
    })(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
    //---- Completion Support --------------------------
    /**
     * Request to request completion at a given text document position. The request's
     * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
     * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
     * or a Thenable that resolves to such.
     */
    var CompletionRequest;
    (function (CompletionRequest) {
        CompletionRequest.type = { get method() { return 'textDocument/completion'; } };
    })(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
    /**
     * Request to resolve additional information for a given completion item.The request's
     * parameter is of type [CompletionItem](#CompletionItem) the response
     * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
     */
    var CompletionResolveRequest;
    (function (CompletionResolveRequest) {
        CompletionResolveRequest.type = { get method() { return 'completionItem/resolve'; } };
    })(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
    //---- Hover Support -------------------------------
    /**
     * Request to request hover information at a given text document position. The request's
     * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
     * type [Hover](#Hover) or a Thenable that resolves to such.
     */
    var HoverRequest;
    (function (HoverRequest) {
        HoverRequest.type = { get method() { return 'textDocument/hover'; } };
    })(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
    //---- SignatureHelp ----------------------------------
    var SignatureHelpRequest;
    (function (SignatureHelpRequest) {
        SignatureHelpRequest.type = { get method() { return 'textDocument/signatureHelp'; } };
    })(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
    //---- Goto Definition -------------------------------------
    /**
     * A request to resolve the defintion location of a symbol at a given text
     * document position. The request's parameter is of type [TextDocumentPosition]
     * (#TextDocumentPosition) the response is of type [Definition](#Definition) or a
     * Thenable that resolves to such.
     */
    var DefinitionRequest;
    (function (DefinitionRequest) {
        DefinitionRequest.type = { get method() { return 'textDocument/definition'; } };
    })(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
    /**
     * A request to resolve project-wide references for the symbol denoted
     * by the given text document position. The request's parameter is of
     * type [ReferenceParams](#ReferenceParams) the response is of type
     * [Location[]](#Location) or a Thenable that resolves to such.
     */
    var ReferencesRequest;
    (function (ReferencesRequest) {
        ReferencesRequest.type = { get method() { return 'textDocument/references'; } };
    })(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
    //---- Document Highlight ----------------------------------
    /**
     * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
     * text document position. The request's parameter is of type [TextDocumentPosition]
     * (#TextDocumentPosition) the request reponse is of type [DocumentHighlight[]]
     * (#DocumentHighlight) or a Thenable that resolves to such.
     */
    var DocumentHighlightRequest;
    (function (DocumentHighlightRequest) {
        DocumentHighlightRequest.type = { get method() { return 'textDocument/documentHighlight'; } };
    })(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
    //---- Document Symbol Provider ---------------------------
    /**
     * A request to list all symbols found in a given text document. The request's
     * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
     * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
     * that resolves to such.
     */
    var DocumentSymbolRequest;
    (function (DocumentSymbolRequest) {
        DocumentSymbolRequest.type = { get method() { return 'textDocument/documentSymbol'; } };
    })(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
    //---- Workspace Symbol Provider ---------------------------
    /**
     * A request to list project-wide symbols matching the query string given
     * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
     * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
     * resolves to such.
     */
    var WorkspaceSymbolRequest;
    (function (WorkspaceSymbolRequest) {
        WorkspaceSymbolRequest.type = { get method() { return 'workspace/symbol'; } };
    })(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
    /**
     * A request to provide commands for the given text document and range.
     */
    var CodeActionRequest;
    (function (CodeActionRequest) {
        CodeActionRequest.type = { get method() { return 'textDocument/codeAction'; } };
    })(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
    /**
     * A request to provide code lens for the given text document.
     */
    var CodeLensRequest;
    (function (CodeLensRequest) {
        CodeLensRequest.type = { get method() { return 'textDocument/codeLens'; } };
    })(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
    /**
     * A request to resolve a command for a given code lens.
     */
    var CodeLensResolveRequest;
    (function (CodeLensResolveRequest) {
        CodeLensResolveRequest.type = { get method() { return 'codeLens/resolve'; } };
    })(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
    /**
     * A request to to format a whole document.
     */
    var DocumentFormattingRequest;
    (function (DocumentFormattingRequest) {
        DocumentFormattingRequest.type = { get method() { return 'textDocument/formatting'; } };
    })(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
    /**
     * A request to to format a range in a document.
     */
    var DocumentRangeFormattingRequest;
    (function (DocumentRangeFormattingRequest) {
        DocumentRangeFormattingRequest.type = { get method() { return 'textDocument/rangeFormatting'; } };
    })(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
    /**
     * A request to format a document on type.
     */
    var DocumentOnTypeFormattingRequest;
    (function (DocumentOnTypeFormattingRequest) {
        DocumentOnTypeFormattingRequest.type = { get method() { return 'textDocument/onTypeFormatting'; } };
    })(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
    /**
     * A request to rename a symbol.
     */
    var RenameRequest;
    (function (RenameRequest) {
        RenameRequest.type = { get method() { return 'textDocument/rename'; } };
    })(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
    /**
     * A request to provide document links
     */
    var DocumentLinkRequest;
    (function (DocumentLinkRequest) {
        DocumentLinkRequest.type = { get method() { return 'textDocument/documentLink'; } };
    })(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
    /**
     * Request to resolve additional information for a given document link. The request's
     * parameter is of type [DocumentLink](#DocumentLink) the response
     * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
     */
    var DocumentLinkResolveRequest;
    (function (DocumentLinkResolveRequest) {
        DocumentLinkResolveRequest.type = { get method() { return 'documentLink/resolve'; } };
    })(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
    /**
     * A request send from the client to the server to execute a command. The request might return
     * a workspace edit which the client will apply to the workspace.
     */
    var ExecuteCommandRequest;
    (function (ExecuteCommandRequest) {
        ExecuteCommandRequest.type = { get method() { return 'workspace/executeCommand'; } };
    })(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
    /**
     * A request sent from the server to the client to modified certain files.
     */
    var ApplyWorkspaceEditRequest;
    (function (ApplyWorkspaceEditRequest) {
        ApplyWorkspaceEditRequest.type = { get method() { return 'workspace/applyEdit'; } };
    })(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
});
define("utils/is", ["require", "exports"], function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var toString = Object.prototype.toString;
    function boolean(value) {
        return value === true || value === false;
    }
    exports.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    exports.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    exports.number = number;
    function error(value) {
        return toString.call(value) === '[object Error]';
    }
    exports.error = error;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    exports.func = func;
    function array(value) {
        return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
        return array(value) && value.every(function (elem) { return string(elem); });
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function thenable(value) {
        return value && func(value.then);
    }
    exports.thenable = thenable;
});
define("protocolCompletionItem", ["require", "exports", 'vscode'], function (require, exports, code) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var ProtocolCompletionItem = (function (_super) {
        __extends(ProtocolCompletionItem, _super);
        function ProtocolCompletionItem(label) {
            _super.call(this, label);
        }
        return ProtocolCompletionItem;
    }(code.CompletionItem));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = ProtocolCompletionItem;
});
define("protocolCodeLens", ["require", "exports", 'vscode'], function (require, exports, code) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var ProtocolCodeLens = (function (_super) {
        __extends(ProtocolCodeLens, _super);
        function ProtocolCodeLens(range) {
            _super.call(this, range);
        }
        return ProtocolCodeLens;
    }(code.CodeLens));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = ProtocolCodeLens;
});
define("codeConverter", ["require", "exports", 'vscode', 'vscode-languageserver-types', "utils/is", "protocolCompletionItem", "protocolCodeLens"], function (require, exports, code, types, is, protocolCompletionItem_1, protocolCodeLens_1) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    function createConverter(uriConverter) {
        var nullConverter = function (value) { return value.toString(); };
        var _uriConverter = uriConverter || nullConverter;
        function asUri(value) {
            return _uriConverter(value);
        }
        function asTextDocumentIdentifier(textDocument) {
            return {
                uri: _uriConverter(textDocument.uri)
            };
        }
        function asVersionedTextDocumentIdentifier(textDocument) {
            return {
                uri: _uriConverter(textDocument.uri),
                version: textDocument.version
            };
        }
        function asOpenTextDocumentParams(textDocument) {
            return {
                textDocument: {
                    uri: _uriConverter(textDocument.uri),
                    languageId: textDocument.languageId,
                    version: textDocument.version,
                    text: textDocument.getText()
                }
            };
        }
        function isTextDocumentChangeEvent(value) {
            var candidate = value;
            return !!candidate.document && !!candidate.contentChanges;
        }
        function isTextDocument(value) {
            var candidate = value;
            return !!candidate.uri && !!candidate.version;
        }
        function asChangeTextDocumentParams(arg) {
            if (isTextDocument(arg)) {
                var result = {
                    textDocument: {
                        uri: _uriConverter(arg.uri),
                        version: arg.version
                    },
                    contentChanges: [{ text: arg.getText() }]
                };
                return result;
            }
            else if (isTextDocumentChangeEvent(arg)) {
                var document = arg.document;
                var result = {
                    textDocument: {
                        uri: _uriConverter(document.uri),
                        version: document.version
                    },
                    contentChanges: arg.contentChanges.map(function (change) {
                        var range = change.range;
                        return {
                            range: {
                                start: { line: range.start.line, character: range.start.character },
                                end: { line: range.end.line, character: range.end.character }
                            },
                            rangeLength: change.rangeLength,
                            text: change.text
                        };
                    })
                };
                return result;
            }
            else {
                throw Error('Unsupported text document change parameter');
            }
        }
        function asCloseTextDocumentParams(textDocument) {
            return {
                textDocument: asTextDocumentIdentifier(textDocument)
            };
        }
        function asSaveTextDocumentParams(textDocument, includeContent) {
            if (includeContent === void 0) { includeContent = false; }
            var result = {
                textDocument: asVersionedTextDocumentIdentifier(textDocument)
            };
            if (includeContent) {
                result.content = textDocument.getText();
            }
            return result;
        }
        function asWillSaveTextDocumentParams(event) {
            return {
                textDocument: asTextDocumentIdentifier(event.document),
                reason: event.reason
            };
        }
        function asTextDocumentPositionParams(textDocument, position) {
            return {
                textDocument: asTextDocumentIdentifier(textDocument),
                position: asWorkerPosition(position)
            };
        }
        function asWorkerPosition(position) {
            return { line: position.line, character: position.character };
        }
        function asPosition(value) {
            if (value === void 0) {
                return undefined;
            }
            else if (value === null) {
                return null;
            }
            return { line: value.line, character: value.character };
        }
        function asRange(value) {
            if (value === void 0) {
                return undefined;
            }
            else if (value === null) {
                return null;
            }
            return { start: asPosition(value.start), end: asPosition(value.end) };
        }
        function asDiagnosticSeverity(value) {
            switch (value) {
                case code.DiagnosticSeverity.Error:
                    return 1 /* Error */;
                case code.DiagnosticSeverity.Warning:
                    return 2 /* Warning */;
                case code.DiagnosticSeverity.Information:
                    return 3 /* Information */;
                case code.DiagnosticSeverity.Hint:
                    return 4 /* Hint */;
            }
        }
        function asDiagnostic(item) {
            var result = types.Diagnostic.create(asRange(item.range), item.message);
            if (item.severity) {
                result.severity = asDiagnosticSeverity(item.severity);
            }
            if (item.code) {
                result.code = item.code;
            }
            if (item.source) {
                result.source = item.source;
            }
            return result;
        }
        function asDiagnostics(items) {
            if (items === void 0 || items === null) {
                return items;
            }
            return items.map(asDiagnostic);
        }
        function asCompletionItem(item) {
            var result = { label: item.label };
            if (item.detail) {
                result.detail = item.detail;
            }
            if (item.documentation) {
                result.documentation = item.documentation;
            }
            if (item.filterText) {
                result.filterText = item.filterText;
            }
            if (item.insertText) {
                result.insertText = asCompletionInsertText(item.insertText);
            }
            if (item.range) {
                result.range = asRange(item.range);
            }
            // Protocol item kind is 1 based, codes item kind is zero based.
            if (item.kind) {
                result.kind = item.kind + 1;
            }
            if (item.sortText) {
                result.sortText = item.sortText;
            }
            if (item.textEdit) {
                result.textEdit = asTextEdit(item.textEdit);
            }
            if (item.additionalTextEdits) {
                result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
            }
            if (item.command) {
                result.command = asCommand(item.command);
            }
            if (item instanceof protocolCompletionItem_1.default) {
                if (item.data) {
                    result.data = item.data;
                }
            }
            return result;
        }
        function asCompletionInsertText(text) {
            if (is.string(text)) {
                return text;
            }
            else if (text.value) {
                return types.SnippetString.create(text.value);
            }
            return undefined;
        }
        function asTextEdit(edit) {
            return { range: asRange(edit.range), newText: edit.newText };
        }
        function asTextEdits(edits) {
            if (edits === void 0 || edits === null) {
                return edits;
            }
            return edits.map(asTextEdit);
        }
        function asReferenceParams(textDocument, position, options) {
            return {
                textDocument: asTextDocumentIdentifier(textDocument),
                position: asWorkerPosition(position),
                context: { includeDeclaration: options.includeDeclaration }
            };
        }
        function asCodeActionContext(context) {
            if (context === void 0 || context === null) {
                return context;
            }
            return types.CodeActionContext.create(asDiagnostics(context.diagnostics));
        }
        function asCommand(item) {
            var result = types.Command.create(item.title, item.command);
            if (item.arguments) {
                result.arguments = item.arguments;
            }
            return result;
        }
        function asCodeLens(item) {
            var result = types.CodeLens.create(asRange(item.range));
            if (item.command) {
                result.command = asCommand(item.command);
            }
            if (item instanceof protocolCodeLens_1.default) {
                if (item.data) {
                    result.data = item.data;
                }
                ;
            }
            return result;
        }
        function asFormattingOptions(item) {
            return { tabSize: item.tabSize, insertSpaces: item.insertSpaces };
        }
        function asDocumentSymbolParams(textDocument) {
            return {
                textDocument: asTextDocumentIdentifier(textDocument)
            };
        }
        function asCodeLensParams(textDocument) {
            return {
                textDocument: asTextDocumentIdentifier(textDocument)
            };
        }
        function asDocumentLink(item) {
            var result = types.DocumentLink.create(asRange(item.range));
            if (item.target) {
                result.target = asUri(item.target);
            }
            return result;
        }
        function asDocumentLinkParams(textDocument) {
            return {
                textDocument: asTextDocumentIdentifier(textDocument)
            };
        }
        return {
            asUri: asUri,
            asTextDocumentIdentifier: asTextDocumentIdentifier,
            asOpenTextDocumentParams: asOpenTextDocumentParams,
            asChangeTextDocumentParams: asChangeTextDocumentParams,
            asCloseTextDocumentParams: asCloseTextDocumentParams,
            asSaveTextDocumentParams: asSaveTextDocumentParams,
            asWillSaveTextDocumentParams: asWillSaveTextDocumentParams,
            asTextDocumentPositionParams: asTextDocumentPositionParams,
            asWorkerPosition: asWorkerPosition,
            asRange: asRange,
            asPosition: asPosition,
            asDiagnosticSeverity: asDiagnosticSeverity,
            asDiagnostic: asDiagnostic,
            asDiagnostics: asDiagnostics,
            asCompletionItem: asCompletionItem,
            asTextEdit: asTextEdit,
            asReferenceParams: asReferenceParams,
            asCodeActionContext: asCodeActionContext,
            asCommand: asCommand,
            asCodeLens: asCodeLens,
            asFormattingOptions: asFormattingOptions,
            asDocumentSymbolParams: asDocumentSymbolParams,
            asCodeLensParams: asCodeLensParams,
            asDocumentLink: asDocumentLink,
            asDocumentLinkParams: asDocumentLinkParams
        };
    }
    exports.createConverter = createConverter;
});
define("protocolConverter", ["require", "exports", 'vscode', 'vscode-languageserver-types', "utils/is", "protocolCompletionItem", "protocolCodeLens"], function (require, exports, code, ls, is, protocolCompletionItem_2, protocolCodeLens_2) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    function createConverter(uriConverter) {
        var nullConverter = function (value) { return code.Uri.parse(value); };
        var _uriConverter = uriConverter || nullConverter;
        function asUri(value) {
            return _uriConverter(value);
        }
        function asDiagnostics(diagnostics) {
            return diagnostics.map(asDiagnostic);
        }
        function asDiagnostic(diagnostic) {
            var result = new code.Diagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity));
            if (diagnostic.code) {
                result.code = diagnostic.code;
            }
            if (diagnostic.source) {
                result.source = diagnostic.source;
            }
            return result;
        }
        function asPosition(value) {
            if (!value) {
                return undefined;
            }
            return new code.Position(value.line, value.character);
        }
        function asRange(value) {
            if (!value) {
                return undefined;
            }
            return new code.Range(asPosition(value.start), asPosition(value.end));
        }
        function asDiagnosticSeverity(value) {
            if (value === void 0 || value === null) {
                return code.DiagnosticSeverity.Error;
            }
            switch (value) {
                case 1 /* Error */:
                    return code.DiagnosticSeverity.Error;
                case 2 /* Warning */:
                    return code.DiagnosticSeverity.Warning;
                case 3 /* Information */:
                    return code.DiagnosticSeverity.Information;
                case 4 /* Hint */:
                    return code.DiagnosticSeverity.Hint;
            }
            return code.DiagnosticSeverity.Error;
        }
        function asHover(hover) {
            if (!hover) {
                return undefined;
            }
            return new code.Hover(hover.contents, asRange(hover.range));
        }
        function asCompletionResult(result) {
            if (!result) {
                return undefined;
            }
            if (Array.isArray(result)) {
                var items = result;
                return items.map(asCompletionItem);
            }
            var list = result;
            return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);
        }
        function asCompletionItem(item) {
            var result = new protocolCompletionItem_2.default(item.label);
            if (item.detail) {
                result.detail = item.detail;
            }
            if (item.documentation) {
                result.documentation = item.documentation;
            }
            ;
            if (item.filterText) {
                result.filterText = item.filterText;
            }
            if (item.insertText) {
                result.insertText = asCompletionInsertText(item.insertText);
            }
            if (item.range) {
                result.range = asRange(item.range);
            }
            // Protocol item kind is 1 based, codes item kind is zero based.
            if (item.kind) {
                result.kind = item.kind - 1;
            }
            if (item.sortText) {
                result.sortText = item.sortText;
            }
            if (item.textEdit) {
                result.textEdit = asTextEdit(item.textEdit);
            }
            if (item.additionalTextEdits) {
                result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
            }
            if (item.command) {
                result.command = asCommand(item.command);
            }
            if (item.data) {
                result.data = item.data;
            }
            return result;
        }
        function asCompletionInsertText(text) {
            if (is.string(text)) {
                return text;
            }
            else if (ls.SnippetString.is(text)) {
                return new code.SnippetString(text.value);
            }
            return undefined;
        }
        function asTextEdit(edit) {
            return new code.TextEdit(asRange(edit.range), edit.newText);
        }
        function asTextEdits(items) {
            if (!items) {
                return undefined;
            }
            return items.map(asTextEdit);
        }
        function asSignatureHelp(item) {
            if (!item) {
                return undefined;
            }
            var result = new code.SignatureHelp();
            if (is.number(item.activeSignature)) {
                result.activeSignature = item.activeSignature;
            }
            else {
                // activeSignature was optional in the past
                result.activeSignature = 0;
            }
            if (is.number(item.activeParameter)) {
                result.activeParameter = item.activeParameter;
            }
            else {
                // activeParameter was optional in the past
                result.activeParameter = 0;
            }
            if (item.signatures) {
                result.signatures = asSignatureInformations(item.signatures);
            }
            return result;
        }
        function asSignatureInformations(items) {
            return items.map(asSignatureInformation);
        }
        function asSignatureInformation(item) {
            var result = new code.SignatureInformation(item.label);
            if (item.documentation) {
                result.documentation = item.documentation;
            }
            if (item.parameters) {
                result.parameters = asParameterInformations(item.parameters);
            }
            return result;
        }
        function asParameterInformations(item) {
            return item.map(asParameterInformation);
        }
        function asParameterInformation(item) {
            var result = new code.ParameterInformation(item.label);
            if (item.documentation) {
                result.documentation = item.documentation;
            }
            ;
            return result;
        }
        function asDefinitionResult(item) {
            if (!item) {
                return undefined;
            }
            if (is.array(item)) {
                return item.map(function (location) { return asLocation(location); });
            }
            else {
                return asLocation(item);
            }
        }
        function asLocation(item) {
            if (!item) {
                return undefined;
            }
            return new code.Location(_uriConverter(item.uri), asRange(item.range));
        }
        function asReferences(values) {
            if (!values) {
                return undefined;
            }
            return values.map(function (location) { return asLocation(location); });
        }
        function asDocumentHighlights(values) {
            if (!values) {
                return undefined;
            }
            return values.map(asDocumentHighlight);
        }
        function asDocumentHighlight(item) {
            var result = new code.DocumentHighlight(asRange(item.range));
            if (item.kind) {
                result.kind = asDocumentHighlightKind(item.kind);
            }
            return result;
        }
        function asDocumentHighlightKind(item) {
            switch (item) {
                case 1 /* Text */:
                    return code.DocumentHighlightKind.Text;
                case 2 /* Read */:
                    return code.DocumentHighlightKind.Read;
                case 3 /* Write */:
                    return code.DocumentHighlightKind.Write;
            }
            return code.DocumentHighlightKind.Text;
        }
        function asSymbolInformations(values, uri) {
            if (!values) {
                return undefined;
            }
            return values.map(function (information) { return asSymbolInformation(information, uri); });
        }
        function asSymbolInformation(item, uri) {
            // Symbol kind is one based in the protocol and zero based in code.
            var result = new code.SymbolInformation(item.name, item.kind - 1, asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);
            if (item.containerName) {
                result.containerName = item.containerName;
            }
            return result;
        }
        function asCommand(item) {
            var result = { title: item.title, command: item.command };
            if (item.arguments) {
                result.arguments = item.arguments;
            }
            return result;
        }
        function asCommands(items) {
            if (!items) {
                return undefined;
            }
            return items.map(asCommand);
        }
        function asCodeLens(item) {
            if (!item) {
                return undefined;
            }
            var result = new protocolCodeLens_2.default(asRange(item.range));
            if (item.command) {
                result.command = asCommand(item.command);
            }
            if (item.data) {
                result.data = item.data;
            }
            return result;
        }
        function asCodeLenses(items) {
            if (!items) {
                return undefined;
            }
            return items.map(function (codeLens) { return asCodeLens(codeLens); });
        }
        function asWorkspaceEdit(item) {
            if (!item) {
                return undefined;
            }
            var result = new code.WorkspaceEdit();
            item.changes.forEach(function (change) {
                result.set(_uriConverter(change.textDocument.uri), asTextEdits(change.edits));
            });
            return result;
        }
        function asDocumentLink(item) {
            var range = asRange(item.range);
            var target = item.target ? asUri(item.target) : undefined;
            // target must be optional in DocumentLink
            return new code.DocumentLink(range, target);
        }
        function asDocumentLinks(items) {
            if (!items) {
                return undefined;
            }
            return items.map(asDocumentLink);
        }
        return {
            asUri: asUri,
            asDiagnostics: asDiagnostics,
            asDiagnostic: asDiagnostic,
            asRange: asRange,
            asPosition: asPosition,
            asDiagnosticSeverity: asDiagnosticSeverity,
            asHover: asHover,
            asCompletionResult: asCompletionResult,
            asCompletionItem: asCompletionItem,
            asTextEdit: asTextEdit,
            asTextEdits: asTextEdits,
            asSignatureHelp: asSignatureHelp,
            asSignatureInformations: asSignatureInformations,
            asSignatureInformation: asSignatureInformation,
            asParameterInformations: asParameterInformations,
            asParameterInformation: asParameterInformation,
            asDefinitionResult: asDefinitionResult,
            asLocation: asLocation,
            asReferences: asReferences,
            asDocumentHighlights: asDocumentHighlights,
            asDocumentHighlight: asDocumentHighlight,
            asDocumentHighlightKind: asDocumentHighlightKind,
            asSymbolInformations: asSymbolInformations,
            asSymbolInformation: asSymbolInformation,
            asCommand: asCommand,
            asCommands: asCommands,
            asCodeLens: asCodeLens,
            asCodeLenses: asCodeLenses,
            asWorkspaceEdit: asWorkspaceEdit,
            asDocumentLink: asDocumentLink,
            asDocumentLinks: asDocumentLinks
        };
    }
    exports.createConverter = createConverter;
});
define("utils/async", ["require", "exports"], function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var Delayer = (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = undefined;
            this.completionPromise = undefined;
            this.onSuccess = undefined;
            this.task = undefined;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            if (delay >= 0) {
                this.cancelTimeout();
            }
            if (!this.completionPromise) {
                this.completionPromise = new Promise(function (resolve) {
                    _this.onSuccess = resolve;
                }).then(function () {
                    _this.completionPromise = undefined;
                    _this.onSuccess = undefined;
                    var result = _this.task();
                    _this.task = undefined;
                    return result;
                });
            }
            if (delay >= 0 || this.timeout === void 0) {
                this.timeout = setTimeout(function () {
                    _this.timeout = undefined;
                    _this.onSuccess(undefined);
                }, delay >= 0 ? delay : this.defaultDelay);
            }
            return this.completionPromise;
        };
        Delayer.prototype.forceDelivery = function () {
            if (!this.completionPromise) {
                return undefined;
            }
            this.cancelTimeout();
            var result = this.task();
            this.completionPromise = undefined;
            this.onSuccess = undefined;
            this.task = undefined;
            return result;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== void 0;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            this.completionPromise = undefined;
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== void 0) {
                clearTimeout(this.timeout);
                this.timeout = undefined;
            }
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
});
define("utils/electron", ["require", "exports", 'path', 'os', 'net', 'child_process'], function (require, exports, path, os, net, cp) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    function makeRandomHexString(length) {
        var chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        var result = '';
        for (var i = 0; i < length; i++) {
            var idx = Math.floor(chars.length * Math.random());
            result += chars[idx];
        }
        return result;
    }
    function generatePipeName() {
        var randomName = 'vscode-' + makeRandomHexString(40);
        if (process.platform === 'win32') {
            return '\\\\.\\pipe\\' + randomName + '-sock';
        }
        // Mac/Unix: use socket file
        return path.join(os.tmpdir(), randomName + '.sock');
    }
    function generatePatchedEnv(env, stdInPipeName, stdOutPipeName) {
        // Set the two unique pipe names and the electron flag as process env
        var newEnv = {};
        for (var key in env) {
            newEnv[key] = env[key];
        }
        newEnv['STDIN_PIPE_NAME'] = stdInPipeName;
        newEnv['STDOUT_PIPE_NAME'] = stdOutPipeName;
        newEnv['ATOM_SHELL_INTERNAL_RUN_AS_NODE'] = '1';
        return newEnv;
    }
    function fork(modulePath, args, options, callback) {
        var callbackCalled = false;
        var resolve = function (result) {
            if (callbackCalled) {
                return;
            }
            callbackCalled = true;
            callback(undefined, result);
        };
        var reject = function (err) {
            if (callbackCalled) {
                return;
            }
            callbackCalled = true;
            callback(err, undefined);
        };
        // Generate two unique pipe names
        var stdInPipeName = generatePipeName();
        var stdOutPipeName = generatePipeName();
        var newEnv = generatePatchedEnv(options.env || process.env, stdInPipeName, stdOutPipeName);
        var childProcess;
        // Begin listening to stdout pipe
        var server = net.createServer(function (stream) {
            // The child process will write exactly one chunk with content `ready` when it has installed a listener to the stdin pipe
            stream.once('data', function (_chunk) {
                // The child process is sending me the `ready` chunk, time to connect to the stdin pipe
                childProcess.stdin = net.connect(stdInPipeName);
                // From now on the childProcess.stdout is available for reading
                childProcess.stdout = stream;
                resolve(childProcess);
            });
        });
        server.listen(stdOutPipeName);
        var serverClosed = false;
        var closeServer = function () {
            if (serverClosed) {
                return;
            }
            serverClosed = true;
            server.close();
        };
        // Create the process
        var bootstrapperPath = path.join(__dirname, 'electronForkStart');
        childProcess = cp.fork(bootstrapperPath, [modulePath].concat(args), {
            silent: true,
            cwd: options.cwd,
            env: newEnv,
            execArgv: options.execArgv
        });
        childProcess.once('error', function (err) {
            closeServer();
            reject(err);
        });
        childProcess.once('exit', function (err) {
            closeServer();
            reject(err);
        });
    }
    exports.fork = fork;
});
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var net = require('net'), fs = require('fs'), stream = require('stream'), util = require('util');
var ENABLE_LOGGING = false;
var log = (function () {
    if (!ENABLE_LOGGING) {
        return function () { };
    }
    var isFirst = true;
    var LOG_LOCATION = 'C:\\stdFork.log';
    return function log(str) {
        if (isFirst) {
            isFirst = false;
            fs.writeFileSync(LOG_LOCATION, str + '\n');
            return;
        }
        fs.appendFileSync(LOG_LOCATION, str + '\n');
    };
})();
var stdInPipeName = process.env['STDIN_PIPE_NAME'];
var stdOutPipeName = process.env['STDOUT_PIPE_NAME'];
log('STDIN_PIPE_NAME: ' + stdInPipeName);
log('STDOUT_PIPE_NAME: ' + stdOutPipeName);
log('ATOM_SHELL_INTERNAL_RUN_AS_NODE: ' + process.env['ATOM_SHELL_INTERNAL_RUN_AS_NODE']);
// stdout redirection to named pipe
(function () {
    log('Beginning stdout redirection...');
    // Create a writing stream to the stdout pipe
    var stdOutStream = net.connect(stdOutPipeName);
    // unref stdOutStream to behave like a normal standard out
    stdOutStream.unref();
    // handle process.stdout
    process.__defineGetter__('stdout', function () { return stdOutStream; });
    // handle process.stderr
    process.__defineGetter__('stderr', function () { return stdOutStream; });
    var fsWriteSyncString = function (fd, str, _position, encoding) {
        //  fs.writeSync(fd, string[, position[, encoding]]);
        var buf = new Buffer(str, encoding || 'utf8');
        return fsWriteSyncBuffer(fd, buf, 0, buf.length);
    };
    var fsWriteSyncBuffer = function (_fd, buffer, off, len) {
        off = Math.abs(off | 0);
        len = Math.abs(len | 0);
        //  fs.writeSync(fd, buffer, offset, length[, position]);
        var buffer_length = buffer.length;
        if (off > buffer_length) {
            throw new Error('offset out of bounds');
        }
        if (len > buffer_length) {
            throw new Error('length out of bounds');
        }
        if (((off + len) | 0) < off) {
            throw new Error('off + len overflow');
        }
        if (buffer_length - off < len) {
            // Asking for more than is left over in the buffer
            throw new Error('off + len > buffer.length');
        }
        var slicedBuffer = buffer;
        if (off !== 0 || len !== buffer_length) {
            slicedBuffer = buffer.slice(off, off + len);
        }
        stdOutStream.write(slicedBuffer);
        return slicedBuffer.length;
    };
    // handle fs.writeSync(1, ...)
    var originalWriteSync = fs.writeSync;
    fs.writeSync = function (fd, data, _position, _encoding) {
        if (fd !== 1) {
            return originalWriteSync.apply(fs, arguments);
        }
        // usage:
        //  fs.writeSync(fd, buffer, offset, length[, position]);
        // OR
        //  fs.writeSync(fd, string[, position[, encoding]]);
        if (data instanceof Buffer) {
            return fsWriteSyncBuffer.apply(null, arguments);
        }
        // For compatibility reasons with fs.writeSync, writing null will write "null", etc
        if (typeof data !== 'string') {
            data += '';
        }
        return fsWriteSyncString.apply(null, arguments);
    };
    log('Finished defining process.stdout, process.stderr and fs.writeSync');
})();
// stdin redirection to named pipe
(function () {
    // Begin listening to stdin pipe
    var server = net.createServer(function (stream) {
        // Stop accepting new connections, keep the existing one alive
        server.close();
        log('Parent process has connected to my stdin. All should be good now.');
        // handle process.stdin
        process.__defineGetter__('stdin', function () {
            return stream;
        });
        // Remove myself from process.argv
        process.argv.splice(1, 1);
        // Load the actual program
        var program = process.argv[1];
        log('Loading program: ' + program);
        // Unset the custom environmental variables that should not get inherited
        delete process.env['STDIN_PIPE_NAME'];
        delete process.env['STDOUT_PIPE_NAME'];
        delete process.env['ATOM_SHELL_INTERNAL_RUN_AS_NODE'];
        require(program);
        log('Finished loading program.');
        var stdinIsReferenced = true;
        var timer = setInterval(function () {
            var listenerCount = (stream.listeners('data').length +
                stream.listeners('end').length +
                stream.listeners('close').length +
                stream.listeners('error').length);
            // log('listenerCount: ' + listenerCount);
            if (listenerCount <= 1) {
                // No more "actual" listeners, only internal node
                if (stdinIsReferenced) {
                    stdinIsReferenced = false;
                    // log('unreferencing stream!!!');
                    stream.unref();
                }
            }
            else {
                // There are "actual" listeners
                if (!stdinIsReferenced) {
                    stdinIsReferenced = true;
                    stream.ref();
                }
            }
            // log(
            // 	'' + stream.listeners('data').length +
            // 	' ' + stream.listeners('end').length +
            // 	' ' + stream.listeners('close').length +
            // 	' ' + stream.listeners('error').length
            // );
        }, 1000);
        timer.unref();
    });
    server.listen(stdInPipeName, function () {
        // signal via stdout that the parent process can now begin writing to stdin pipe
        process.stdout.write('ready');
    });
})();
define("utils/processes", ["require", "exports", 'child_process', 'path'], function (require, exports, cp, path_1) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    var isWindows = (process.platform === 'win32');
    var isMacintosh = (process.platform === 'darwin');
    var isLinux = (process.platform === 'linux');
    function terminate(process, cwd) {
        if (isWindows) {
            try {
                // This we run in Atom execFileSync is available.
                // Ignore stderr since this is otherwise piped to parent.stderr
                // which might be already closed.
                var options = {
                    stdio: ['pipe', 'pipe', 'ignore']
                };
                if (cwd) {
                    options.cwd = cwd;
                }
                cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
                return true;
            }
            catch (err) {
                return false;
            }
        }
        else if (isLinux || isMacintosh) {
            try {
                var cmd = path_1.join(__dirname, 'terminateProcess.sh');
                var result = cp.spawnSync(cmd, [process.pid.toString()]);
                return result.error ? false : true;
            }
            catch (err) {
                return false;
            }
        }
        else {
            process.kill('SIGKILL');
            return true;
        }
    }
    exports.terminate = terminate;
});
define("utils/uuid", ["require", "exports"], function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ValueUUID = (function () {
        function ValueUUID(_value) {
            this._value = _value;
            // empty
        }
        ValueUUID.prototype.asHex = function () {
            return this._value;
        };
        ValueUUID.prototype.equals = function (other) {
            return this.asHex() === other.asHex();
        };
        return ValueUUID;
    }());
    var V4UUID = (function (_super) {
        __extends(V4UUID, _super);
        function V4UUID() {
            _super.call(this, [
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                '4',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._oneOf(V4UUID._timeHighBits),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
            ].join(''));
        }
        V4UUID._oneOf = function (array) {
            return array[Math.floor(array.length * Math.random())];
        };
        V4UUID._randomHex = function () {
            return V4UUID._oneOf(V4UUID._chars);
        };
        V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
        return V4UUID;
    }(ValueUUID));
    /**
     * An empty UUID that contains only zeros.
     */
    exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
    function v4() {
        return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
        return _UUIDPattern.test(value);
    }
    exports.isUUID = isUUID;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    function parse(value) {
        if (!isUUID(value)) {
            throw new Error('invalid uuid');
        }
        return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
        return v4().asHex();
    }
    exports.generateUuid = generateUuid;
});
define("vscode-languageclient", ["require", "exports", 'child_process', 'vscode', 'vscode-jsonrpc', "protocol", "codeConverter", "protocolConverter", "utils/is", "utils/electron", "utils/processes", "utils/async", "utils/uuid", 'vscode-languageserver-types'], function (require, exports, cp, vscode_1, vscode_jsonrpc_1, protocol_1, c2p, p2c, is, electron, processes_1, async_1, UUID, vscode_languageserver_types_1) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    function __export(m) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
    exports.ErrorCodes = vscode_jsonrpc_1.ErrorCodes;
    exports.ResponseError = vscode_jsonrpc_1.ResponseError;
    exports.Trace = vscode_jsonrpc_1.Trace;
    exports.Event = vscode_jsonrpc_1.Event;
    exports.Emitter = vscode_jsonrpc_1.Emitter;
    __export(vscode_languageserver_types_1);
    var ConsoleLogger = (function () {
        function ConsoleLogger() {
        }
        ConsoleLogger.prototype.error = function (message) {
            console.error(message);
        };
        ConsoleLogger.prototype.warn = function (message) {
            console.warn(message);
        };
        ConsoleLogger.prototype.info = function (message) {
            console.info(message);
        };
        ConsoleLogger.prototype.log = function (message) {
            console.log(message);
        };
        return ConsoleLogger;
    }());
    function createConnection(input, output, errorHandler, closeHandler) {
        var logger = new ConsoleLogger();
        var connection = vscode_jsonrpc_1.createMessageConnection(input, output, logger);
        connection.onError(function (data) { errorHandler(data[0], data[1], data[2]); });
        connection.onClose(closeHandler);
        var result = {
            listen: function () { return connection.listen(); },
            sendRequest: function (type) {
                var params = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    params[_i - 1] = arguments[_i];
                }
                return connection.sendRequest.apply(connection, [is.string(type) ? type : type.method].concat(params));
            },
            onRequest: function (type, handler) { return connection.onRequest(is.string(type) ? type : type.method, handler); },
            sendNotification: function (type, params) { return connection.sendNotification(is.string(type) ? type : type.method, params); },
            onNotification: function (type, handler) { return connection.onNotification(is.string(type) ? type : type.method, handler); },
            trace: function (value, tracer, sendNotification) {
                if (sendNotification === void 0) { sendNotification = false; }
                return connection.trace(value, tracer, sendNotification);
            },
            initialize: function (params) { return connection.sendRequest(protocol_1.InitializeRequest.type, params); },
            shutdown: function () { return connection.sendRequest(protocol_1.ShutdownRequest.type, undefined); },
            exit: function () { return connection.sendNotification(protocol_1.ExitNotification.type); },
            onLogMessage: function (handler) { return connection.onNotification(protocol_1.LogMessageNotification.type, handler); },
            onShowMessage: function (handler) { return connection.onNotification(protocol_1.ShowMessageNotification.type, handler); },
            onTelemetry: function (handler) { return connection.onNotification(protocol_1.TelemetryEventNotification.type, handler); },
            didChangeConfiguration: function (params) { return connection.sendNotification(protocol_1.DidChangeConfigurationNotification.type, params); },
            didChangeWatchedFiles: function (params) { return connection.sendNotification(protocol_1.DidChangeWatchedFilesNotification.type, params); },
            didOpenTextDocument: function (params) { return connection.sendNotification(protocol_1.DidOpenTextDocumentNotification.type, params); },
            didChangeTextDocument: function (params) { return connection.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, params); },
            didCloseTextDocument: function (params) { return connection.sendNotification(protocol_1.DidCloseTextDocumentNotification.type, params); },
            didSaveTextDocument: function (params) { return connection.sendNotification(protocol_1.DidSaveTextDocumentNotification.type, params); },
            onDiagnostics: function (handler) { return connection.onNotification(protocol_1.PublishDiagnosticsNotification.type, handler); },
            dispose: function () { return connection.dispose(); }
        };
        return result;
    }
    (function (TransportKind) {
        TransportKind[TransportKind["stdio"] = 0] = "stdio";
        TransportKind[TransportKind["ipc"] = 1] = "ipc";
    })(exports.TransportKind || (exports.TransportKind = {}));
    var TransportKind = exports.TransportKind;
    /**
     * An action to be performed when the connection is producing errors.
     */
    (function (ErrorAction) {
        /**
         * Continue running the server.
         */
        ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
        /**
         * Shutdown the server.
         */
        ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
    })(exports.ErrorAction || (exports.ErrorAction = {}));
    var ErrorAction = exports.ErrorAction;
    /**
     * An action to be performed when the connection to a server got closed.
     */
    (function (CloseAction) {
        /**
         * Don't restart the server. The connection stays closed.
         */
        CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
        /**
         * Restart the server.
         */
        CloseAction[CloseAction["Restart"] = 2] = "Restart";
    })(exports.CloseAction || (exports.CloseAction = {}));
    var CloseAction = exports.CloseAction;
    var DefaultErrorHandler = (function () {
        function DefaultErrorHandler(name) {
            this.name = name;
            this.restarts = [];
        }
        DefaultErrorHandler.prototype.error = function (_error, _message, count) {
            if (count && count <= 3) {
                return ErrorAction.Continue;
            }
            return ErrorAction.Shutdown;
        };
        DefaultErrorHandler.prototype.closed = function () {
            this.restarts.push(Date.now());
            if (this.restarts.length < 5) {
                return CloseAction.Restart;
            }
            else {
                var diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
                if (diff <= 3 * 60 * 1000) {
                    vscode_1.window.showErrorMessage("The " + this.name + " server crashed 5 times in the last 3 minutes. The server will not be restarted.");
                    return CloseAction.DoNotRestart;
                }
                else {
                    this.restarts.shift();
                    return CloseAction.Restart;
                }
            }
        };
        return DefaultErrorHandler;
    }());
    (function (RevealOutputChannelOn) {
        RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
        RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
        RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
        RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
    })(exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
    var RevealOutputChannelOn = exports.RevealOutputChannelOn;
    (function (State) {
        State[State["Stopped"] = 1] = "Stopped";
        State[State["Running"] = 2] = "Running";
    })(exports.State || (exports.State = {}));
    var State = exports.State;
    var ClientState;
    (function (ClientState) {
        ClientState[ClientState["Initial"] = 0] = "Initial";
        ClientState[ClientState["Starting"] = 1] = "Starting";
        ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
        ClientState[ClientState["Running"] = 3] = "Running";
        ClientState[ClientState["Stopping"] = 4] = "Stopping";
        ClientState[ClientState["Stopped"] = 5] = "Stopped";
    })(ClientState || (ClientState = {}));
    var DocumentNotifiactions = (function () {
        function DocumentNotifiactions(_client, _event, _type, _createParams, _selectorFilter) {
            this._client = _client;
            this._event = _event;
            this._type = _type;
            this._createParams = _createParams;
            this._selectorFilter = _selectorFilter;
            this._selectors = new Map();
        }
        DocumentNotifiactions.textDocumentFilter = function (selectors, textDocument) {
            var items = Array.from(selectors);
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var selector = items_1[_i];
                if (vscode_1.languages.match(selector, textDocument)) {
                    return true;
                }
            }
            return false;
        };
        DocumentNotifiactions.prototype.register = function (data) {
            if (!data.registerOptions.documentSelector) {
                return;
            }
            if (!this._listener) {
                this._listener = this._event(this.callback, this);
            }
            this._selectors.set(data.id, data.registerOptions.documentSelector);
        };
        DocumentNotifiactions.prototype.callback = function (data) {
            if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
                this._client.sendNotification(this._type, this._createParams(data));
                this.notificationSent(data);
            }
        };
        DocumentNotifiactions.prototype.notificationSent = function (_data) {
        };
        DocumentNotifiactions.prototype.unregister = function (id) {
            this._selectors.delete(id);
            if (this._selectors.size === 0) {
                this._listener.dispose();
                this._listener = undefined;
            }
        };
        DocumentNotifiactions.prototype.dispose = function () {
            if (this._listener) {
                this._listener.dispose();
            }
        };
        return DocumentNotifiactions;
    }());
    var DidOpenTextDocumentFeature = (function (_super) {
        __extends(DidOpenTextDocumentFeature, _super);
        function DidOpenTextDocumentFeature(client, _syncedDocuments) {
            _super.call(this, client, vscode_1.workspace.onDidOpenTextDocument, protocol_1.DidOpenTextDocumentNotification.type, function (textDocument) { return client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument); }, DocumentNotifiactions.textDocumentFilter);
            this._syncedDocuments = _syncedDocuments;
        }
        DidOpenTextDocumentFeature.prototype.register = function (data) {
            var _this = this;
            _super.prototype.register.call(this, data);
            if (!data.registerOptions.documentSelector) {
                return;
            }
            vscode_1.workspace.textDocuments.forEach(function (textDocument) {
                var uri = textDocument.uri.toString();
                if (_this._syncedDocuments.has(uri)) {
                    return;
                }
                if (vscode_1.languages.match(data.registerOptions.documentSelector, textDocument)) {
                    _this._client.sendNotification(_this._type, _this._createParams(textDocument));
                    _this._syncedDocuments.set(uri, textDocument);
                }
            });
        };
        DidOpenTextDocumentFeature.prototype.notificationSent = function (textDocument) {
            _super.prototype.notificationSent.call(this, textDocument);
            this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
        };
        return DidOpenTextDocumentFeature;
    }(DocumentNotifiactions));
    var DidCloseTextDocumentFeature = (function (_super) {
        __extends(DidCloseTextDocumentFeature, _super);
        function DidCloseTextDocumentFeature(client, _syncedDocuments) {
            _super.call(this, client, vscode_1.workspace.onDidCloseTextDocument, protocol_1.DidCloseTextDocumentNotification.type, function (textDocument) { return client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument); }, DocumentNotifiactions.textDocumentFilter);
            this._syncedDocuments = _syncedDocuments;
        }
        DidCloseTextDocumentFeature.prototype.notificationSent = function (textDocument) {
            _super.prototype.notificationSent.call(this, textDocument);
            this._syncedDocuments.delete(textDocument.uri.toString());
        };
        DidCloseTextDocumentFeature.prototype.unregister = function (id) {
            var _this = this;
            var selector = this._selectors.get(id);
            _super.prototype.unregister.call(this, id);
            var selectors = this._selectors.values();
            this._syncedDocuments.forEach(function (textDocument) {
                if (vscode_1.languages.match(selector, textDocument) && !_this._selectorFilter(selectors, textDocument)) {
                    _this._client.sendNotification(_this._type, _this._createParams(textDocument));
                    _this._syncedDocuments.delete(textDocument.uri.toString());
                }
            });
        };
        return DidCloseTextDocumentFeature;
    }(DocumentNotifiactions));
    var DidChangeTextDocumentFeature = (function () {
        function DidChangeTextDocumentFeature(_client) {
            this._client = _client;
            this._changeData = new Map();
            this._forcingDelivery = false;
        }
        DidChangeTextDocumentFeature.prototype.register = function (data) {
            if (!data.registerOptions.documentSelector) {
                return;
            }
            if (!this._listener) {
                this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
            }
            this._changeData.set(data.id, {
                documentSelector: data.registerOptions.documentSelector,
                syncKind: data.registerOptions.syncKind
            });
        };
        DidChangeTextDocumentFeature.prototype.callback = function (event) {
            var _this = this;
            var items = Array.from(this._changeData.values());
            for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
                var changeData = items_2[_i];
                if (vscode_1.languages.match(changeData.documentSelector, event.document)) {
                    if (changeData.syncKind === protocol_1.TextDocumentSyncKind.Incremental) {
                        this._client.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, this._client.code2ProtocolConverter.asChangeTextDocumentParams(event));
                        break;
                    }
                    else if (changeData.syncKind === protocol_1.TextDocumentSyncKind.Full) {
                        if (this._changeDelayer) {
                            if (this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                this.forceDelivery();
                                this._changeDelayer.uri = event.document.uri.toString();
                            }
                            this._changeDelayer.delayer.trigger(function () {
                                _this._client.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, _this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            });
                        }
                        else {
                            this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            this._changeDelayer.delayer.trigger(function () {
                                _this._client.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, _this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document));
                            }, -1);
                        }
                        break;
                    }
                }
            }
        };
        DidChangeTextDocumentFeature.prototype.unregister = function (id) {
            this._changeData.delete(id);
            if (this._changeData.size === 0) {
                this._listener.dispose();
                this._listener = undefined;
            }
        };
        DidChangeTextDocumentFeature.prototype.dispose = function () {
            if (this._listener) {
                this._listener.dispose();
                this._listener = undefined;
            }
        };
        DidChangeTextDocumentFeature.prototype.forceDelivery = function () {
            if (this._forcingDelivery || !this._changeDelayer) {
                return;
            }
            try {
                this._forcingDelivery = true;
                this._changeDelayer.delayer.forceDelivery();
            }
            finally {
                this._forcingDelivery = false;
            }
        };
        return DidChangeTextDocumentFeature;
    }());
    var WillSaveWaitUntilFeature = (function () {
        function WillSaveWaitUntilFeature(_client) {
            this._client = _client;
            this._selectors = new Map();
        }
        WillSaveWaitUntilFeature.prototype.register = function (data) {
            if (!data.registerOptions.documentSelector) {
                return;
            }
            if (!this._listener) {
                this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
            }
            this._selectors.set(data.id, data.registerOptions.documentSelector);
        };
        WillSaveWaitUntilFeature.prototype.callback = function (event) {
            var _this = this;
            if (DocumentNotifiactions.textDocumentFilter(this._selectors.values(), event.document)) {
                event.waitUntil(this._client.sendRequest(protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then(function (edits) {
                    return _this._client.protocol2CodeConverter.asTextEdits(edits);
                }));
            }
        };
        WillSaveWaitUntilFeature.prototype.unregister = function (id) {
            this._selectors.delete(id);
            if (this._selectors.size === 0) {
                this._listener.dispose();
                this._listener = undefined;
            }
        };
        WillSaveWaitUntilFeature.prototype.dispose = function () {
            if (this._listener) {
                this._listener.dispose();
                this._listener = undefined;
            }
        };
        return WillSaveWaitUntilFeature;
    }());
    var LanguageFeature = (function () {
        function LanguageFeature(_createProvider) {
            this._createProvider = _createProvider;
            this._providers = new Map();
        }
        LanguageFeature.prototype.register = function (data) {
            if (!data.registerOptions.documentSelector) {
                return;
            }
            var provider = this._createProvider(data.registerOptions);
            if (provider) {
                this._providers.set(data.id, provider);
            }
        };
        LanguageFeature.prototype.unregister = function (id) {
            var provider = this._providers.get(id);
            if (provider) {
                provider.dispose();
            }
        };
        LanguageFeature.prototype.dispose = function () {
            this._providers.forEach(function (value) {
                value.dispose();
            });
        };
        return LanguageFeature;
    }());
    var ExecuteCommandFeature = (function () {
        function ExecuteCommandFeature(_client, _logger) {
            this._client = _client;
            this._logger = _logger;
            this._commands = new Map();
        }
        ExecuteCommandFeature.prototype.register = function (data) {
            var _this = this;
            if (data.registerOptions.commands) {
                var disposeables = [];
                var _loop_1 = function(command) {
                    disposeables.push(vscode_1.commands.registerCommand(command, function (args) {
                        var params = {
                            command: command,
                            arguments: args
                        };
                        _this._client.sendRequest(protocol_1.ExecuteCommandRequest.type, params).then(undefined, function (error) { _this._logger(protocol_1.ExecuteCommandRequest.type, error); });
                    }));
                };
                for (var _i = 0, _a = data.registerOptions.commands; _i < _a.length; _i++) {
                    var command = _a[_i];
                    _loop_1(command);
                }
                this._commands.set(data.id, disposeables);
            }
        };
        ExecuteCommandFeature.prototype.unregister = function (id) {
            var disposeables = this._commands.get(id);
            if (disposeables) {
                disposeables.forEach(function (disposable) { return disposable.dispose(); });
            }
        };
        ExecuteCommandFeature.prototype.dispose = function () {
            this._commands.forEach(function (value) {
                value.forEach(function (disposable) { return disposable.dispose(); });
            });
        };
        return ExecuteCommandFeature;
    }());
    var LanguageClient = (function () {
        function LanguageClient(arg1, arg2, arg3, arg4, arg5) {
            var _this = this;
            this._registeredHandlers = new Map();
            var clientOptions;
            var forceDebug;
            if (is.string(arg2)) {
                this._id = arg1;
                this._name = arg2;
                this._serverOptions = arg3;
                clientOptions = arg4;
                forceDebug = !!arg5;
            }
            else {
                this._id = arg1.toLowerCase();
                this._name = arg1;
                this._serverOptions = arg2;
                clientOptions = arg3;
                forceDebug = arg4;
            }
            if (forceDebug === void 0) {
                forceDebug = false;
            }
            this._clientOptions = clientOptions || {};
            this._clientOptions.synchronize = this._clientOptions.synchronize || {};
            this._clientOptions.errorHandler = this._clientOptions.errorHandler || new DefaultErrorHandler(this._name);
            this._configuration = clientOptions.configuration || {};
            this._clientOptions.revealOutputChannelOn == this._clientOptions.revealOutputChannelOn || RevealOutputChannelOn.Error;
            this._forceDebug = forceDebug;
            this.state = ClientState.Initial;
            this._connectionPromise = undefined;
            this._resolvedConnection = undefined;
            this._childProcess = undefined;
            this._outputChannel = undefined;
            this._listeners = undefined;
            this._providers = undefined;
            this._diagnostics = undefined;
            this._fileEvents = [];
            this._fileEventDelayer = new async_1.Delayer(250);
            this._onReady = new Promise(function (resolve, reject) {
                _this._onReadyCallbacks = { resolve: resolve, reject: reject };
            });
            this._telemetryEmitter = new vscode_jsonrpc_1.Emitter();
            this._stateChangeEmitter = new vscode_jsonrpc_1.Emitter();
            this._tracer = {
                log: function (message, data) {
                    _this.logTrace(message, data);
                }
            };
            this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
            this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined);
        }
        Object.defineProperty(LanguageClient.prototype, "state", {
            get: function () {
                return this._state;
            },
            set: function (value) {
                var oldState = this.getPublicState();
                this._state = value;
                var newState = this.getPublicState();
                if (newState !== oldState) {
                    this._stateChangeEmitter.fire({ oldState: oldState, newState: newState });
                }
            },
            enumerable: true,
            configurable: true
        });
        LanguageClient.prototype.getPublicState = function () {
            if (this.state === ClientState.Running) {
                return State.Running;
            }
            else {
                return State.Stopped;
            }
        };
        LanguageClient.prototype.sendRequest = function (type) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            if (!this.isConnectionActive()) {
                throw new Error('Language client is not ready yet');
            }
            this.forceDocumentSync();
            try {
                return (_a = this._resolvedConnection).sendRequest.apply(_a, [type].concat(params));
            }
            catch (error) {
                this.error("Sending request " + (is.string(type) ? type : type.method) + " failed.", error);
                throw error;
            }
            var _a;
        };
        LanguageClient.prototype.onRequest = function (type, handler) {
            if (!this.isConnectionActive()) {
                throw new Error('Language client is not ready yet');
            }
            try {
                this._resolvedConnection.onRequest(type, handler);
            }
            catch (error) {
                this.error("Registering request handler " + (is.string(type) ? type : type.method) + " failed.", error);
                throw error;
            }
        };
        LanguageClient.prototype.sendNotification = function (type, params) {
            if (!this.isConnectionActive()) {
                throw new Error('Language client is not ready yet');
            }
            this.forceDocumentSync();
            try {
                this._resolvedConnection.sendNotification(type, params);
            }
            catch (error) {
                this.error("Sending notification " + (is.string(type) ? type : type.method) + " failed.", error);
                throw error;
            }
        };
        LanguageClient.prototype.onNotification = function (type, handler) {
            if (!this.isConnectionActive()) {
                throw new Error('Language client is not ready yet');
            }
            try {
                this._resolvedConnection.onNotification(type, handler);
            }
            catch (error) {
                this.error("Registering notification handler " + (is.string(type) ? type : type.method) + " failed.", error);
                throw error;
            }
        };
        Object.defineProperty(LanguageClient.prototype, "protocol2CodeConverter", {
            get: function () {
                return this._p2c;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LanguageClient.prototype, "code2ProtocolConverter", {
            get: function () {
                return this._c2p;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LanguageClient.prototype, "onTelemetry", {
            get: function () {
                return this._telemetryEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LanguageClient.prototype, "onDidChangeState", {
            get: function () {
                return this._stateChangeEmitter.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LanguageClient.prototype, "outputChannel", {
            get: function () {
                if (!this._outputChannel) {
                    this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
                }
                return this._outputChannel;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(LanguageClient.prototype, "diagnostics", {
            get: function () {
                return this._diagnostics;
            },
            enumerable: true,
            configurable: true
        });
        LanguageClient.prototype.createDefaultErrorHandler = function () {
            return new DefaultErrorHandler(this._name);
        };
        Object.defineProperty(LanguageClient.prototype, "trace", {
            set: function (value) {
                var _this = this;
                this._trace = value;
                this.onReady().then(function () {
                    _this.resolveConnection().then(function (connection) {
                        connection.trace(value, _this._tracer);
                    });
                }, function () {
                });
            },
            enumerable: true,
            configurable: true
        });
        LanguageClient.prototype.data2String = function (data) {
            if (data instanceof vscode_jsonrpc_1.ResponseError) {
                var responseError = data;
                return "  Message: " + responseError.message + "\n  Code: " + responseError.code + " " + (responseError.data ? '\n' + responseError.data.toString() : '');
            }
            if (data instanceof Error) {
                if (is.string(data.stack)) {
                    return data.stack;
                }
                return data.message;
            }
            if (is.string(data)) {
                return data;
            }
            return data.toString();
        };
        LanguageClient.prototype.info = function (message, data) {
            this.outputChannel.appendLine("[Info  - " + (new Date().toLocaleTimeString()) + "] " + message);
            if (data) {
                this.outputChannel.appendLine(this.data2String(data));
            }
            if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
                this.outputChannel.show(true);
            }
        };
        LanguageClient.prototype.warn = function (message, data) {
            this.outputChannel.appendLine("[Warn  - " + (new Date().toLocaleTimeString()) + "] " + message);
            if (data) {
                this.outputChannel.appendLine(this.data2String(data));
            }
            if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
                this.outputChannel.show(true);
            }
        };
        LanguageClient.prototype.error = function (message, data) {
            this.outputChannel.appendLine("[Error - " + (new Date().toLocaleTimeString()) + "] " + message);
            if (data) {
                this.outputChannel.appendLine(this.data2String(data));
            }
            if (this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
                this.outputChannel.show(true);
            }
        };
        LanguageClient.prototype.logTrace = function (message, data) {
            this.outputChannel.appendLine("[Trace - " + (new Date().toLocaleTimeString()) + "] " + message);
            if (data) {
                this.outputChannel.appendLine(this.data2String(data));
            }
            this.outputChannel.show(true);
        };
        LanguageClient.prototype.needsStart = function () {
            return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
        };
        LanguageClient.prototype.needsStop = function () {
            return this.state === ClientState.Starting || this.state === ClientState.Running;
        };
        LanguageClient.prototype.onReady = function () {
            return this._onReady;
        };
        LanguageClient.prototype.isConnectionActive = function () {
            return this.state === ClientState.Running && !!this._resolvedConnection;
        };
        LanguageClient.prototype.start = function () {
            var _this = this;
            this._listeners = [];
            this._providers = [];
            // If we restart then the diagnostics collection is reused.
            if (!this._diagnostics) {
                this._diagnostics = this._clientOptions.diagnosticCollectionName
                    ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                    : vscode_1.languages.createDiagnosticCollection();
            }
            this.state = ClientState.Starting;
            this.resolveConnection().then(function (connection) {
                connection.onLogMessage(function (message) {
                    switch (message.type) {
                        case protocol_1.MessageType.Error:
                            _this.error(message.message);
                            break;
                        case protocol_1.MessageType.Warning:
                            _this.warn(message.message);
                            break;
                        case protocol_1.MessageType.Info:
                            _this.info(message.message);
                            break;
                        default:
                            _this.outputChannel.appendLine(message.message);
                    }
                });
                connection.onShowMessage(function (message) {
                    switch (message.type) {
                        case protocol_1.MessageType.Error:
                            vscode_1.window.showErrorMessage(message.message);
                            break;
                        case protocol_1.MessageType.Warning:
                            vscode_1.window.showWarningMessage(message.message);
                            break;
                        case protocol_1.MessageType.Info:
                            vscode_1.window.showInformationMessage(message.message);
                            break;
                        default:
                            vscode_1.window.showInformationMessage(message.message);
                    }
                });
                connection.onRequest(protocol_1.ShowMessageRequest.type, function (params) {
                    var messageFunc;
                    switch (params.type) {
                        case protocol_1.MessageType.Error:
                            messageFunc = vscode_1.window.showErrorMessage;
                            break;
                        case protocol_1.MessageType.Warning:
                            messageFunc = vscode_1.window.showWarningMessage;
                            break;
                        case protocol_1.MessageType.Info:
                            messageFunc = vscode_1.window.showInformationMessage;
                            break;
                        default:
                            messageFunc = vscode_1.window.showInformationMessage;
                    }
                    var actions = params.actions || [];
                    return messageFunc.apply(void 0, [params.message].concat(actions));
                });
                connection.onTelemetry(function (data) {
                    _this._telemetryEmitter.fire(data);
                });
                _this.initRegistrationHandlers(connection);
                connection.listen();
                // Error is handled in the intialize call.
                _this.initialize(connection).then(undefined, function () { });
            }, function (error) {
                _this.state = ClientState.StartFailed;
                _this._onReadyCallbacks.reject(error);
                _this.error('Starting client failed', error);
                vscode_1.window.showErrorMessage("Couldn't start client " + _this._name);
            });
            return new vscode_1.Disposable(function () {
                if (_this.needsStop()) {
                    _this.stop();
                }
            });
        };
        LanguageClient.prototype.resolveConnection = function () {
            if (!this._connectionPromise) {
                this._connectionPromise = this.createConnection();
            }
            return this._connectionPromise;
        };
        LanguageClient.prototype.initialize = function (connection) {
            var _this = this;
            this.refreshTrace(connection, false);
            var initOption = this._clientOptions.initializationOptions;
            var initParams = {
                processId: process.pid,
                rootPath: vscode_1.workspace.rootPath ? vscode_1.workspace.rootPath : null,
                capabilities: {
                    dynamicRegistration: true,
                    workspace: {
                        applyEdit: true
                    },
                    textDocument: {
                        willSaveNotification: true,
                        willSaveWaitUntilRequest: true
                    }
                },
                initializationOptions: is.func(initOption) ? initOption() : initOption,
                trace: vscode_jsonrpc_1.Trace.toString(this._trace)
            };
            return connection.initialize(initParams).then(function (result) {
                _this._resolvedConnection = connection;
                _this.state = ClientState.Running;
                _this._capabilites = result.capabilities;
                connection.onDiagnostics(function (params) { return _this.handleDiagnostics(params); });
                connection.onRequest(protocol_1.RegistrationRequest.type, function (params) { return _this.handleRegistrationRequest(params); });
                connection.onRequest(protocol_1.UnregistrationRequest.type, function (params) { return _this.handleUnregistrationRequest(params); });
                connection.onRequest(protocol_1.ApplyWorkspaceEditRequest.type, function (params) { return _this.handleApplyWorkspaceEdit(params); });
                connection.sendNotification(protocol_1.InitializedNotification.type, {});
                _this.hookFileEvents(connection);
                _this.hookConfigurationChanged(connection);
                if (_this._capabilites.textDocumentSync !== protocol_1.TextDocumentSyncKind.None && _this._clientOptions.documentSelector) {
                    var selectorOptions = { documentSelector: _this._clientOptions.documentSelector };
                    _this._registeredHandlers.get(protocol_1.DidOpenTextDocumentNotification.type.method).register({ id: UUID.generateUuid(), registerOptions: selectorOptions });
                    _this._registeredHandlers.get(protocol_1.DidChangeTextDocumentNotification.type.method).register({
                        id: UUID.generateUuid(),
                        registerOptions: Object.assign({}, selectorOptions, { syncKind: _this._capabilites.textDocumentSync })
                    });
                    _this._registeredHandlers.get(protocol_1.DidCloseTextDocumentNotification.type.method).register({ id: UUID.generateUuid(), registerOptions: selectorOptions });
                    _this._registeredHandlers.get(protocol_1.DidSaveTextDocumentNotification.type.method).register({ id: UUID.generateUuid(), registerOptions: selectorOptions });
                }
                _this.hookCapabilities(connection);
                _this._onReadyCallbacks.resolve();
                return result;
            }, function (error) {
                if (_this._clientOptions.initializationFailedHandler) {
                    if (_this._clientOptions.initializationFailedHandler(error)) {
                        _this.initialize(connection);
                    }
                    else {
                        _this.stop();
                        _this._onReadyCallbacks.reject(error);
                    }
                }
                else if (error instanceof vscode_jsonrpc_1.ResponseError && error.data && error.data.retry) {
                    vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: "retry" }).then(function (item) {
                        if (item && item.id === 'retry') {
                            _this.initialize(connection);
                        }
                        else {
                            _this.stop();
                            _this._onReadyCallbacks.reject(error);
                        }
                    });
                }
                else {
                    if (error && error.message) {
                        vscode_1.window.showErrorMessage(error.message);
                    }
                    _this.error('Server initialization failed.', error);
                    _this.stop();
                    _this._onReadyCallbacks.reject(error);
                }
            });
        };
        LanguageClient.prototype.stop = function () {
            var _this = this;
            if (!this._connectionPromise) {
                this.state = ClientState.Stopped;
                return Promise.resolve();
            }
            this.state = ClientState.Stopping;
            this.cleanUp();
            // unkook listeners
            return this.resolveConnection().then(function (connection) {
                return connection.shutdown().then(function () {
                    connection.exit();
                    connection.dispose();
                    _this.state = ClientState.Stopped;
                    _this._connectionPromise = undefined;
                    _this._resolvedConnection = undefined;
                    var toCheck = _this._childProcess;
                    _this._childProcess = undefined;
                    // Remove all markers
                    _this.checkProcessDied(toCheck);
                });
            });
        };
        LanguageClient.prototype.cleanUp = function (diagnostics) {
            if (diagnostics === void 0) { diagnostics = true; }
            if (this._listeners) {
                this._listeners.forEach(function (listener) { return listener.dispose(); });
                this._listeners = undefined;
            }
            if (this._providers) {
                this._providers.forEach(function (provider) { return provider.dispose(); });
                this._providers = undefined;
            }
            if (diagnostics && this._diagnostics) {
                this._diagnostics.dispose();
                this._diagnostics = undefined;
            }
        };
        LanguageClient.prototype.notifyFileEvent = function (event) {
            var _this = this;
            this._fileEvents.push(event);
            this._fileEventDelayer.trigger(function () {
                _this.onReady().then(function () {
                    _this.resolveConnection().then(function (connection) {
                        if (_this.isConnectionActive()) {
                            connection.didChangeWatchedFiles({ changes: _this._fileEvents });
                        }
                        _this._fileEvents = [];
                    });
                }, function (error) {
                    _this.error("Notify file events failed.", error);
                });
            });
        };
        LanguageClient.prototype.forceDocumentSync = function () {
            this._registeredHandlers.get(protocol_1.DidChangeTextDocumentNotification.type.method).forceDelivery();
        };
        LanguageClient.prototype.handleDiagnostics = function (params) {
            var uri = this._p2c.asUri(params.uri);
            var diagnostics = this._p2c.asDiagnostics(params.diagnostics);
            this._diagnostics.set(uri, diagnostics);
        };
        LanguageClient.prototype.createConnection = function () {
            var _this = this;
            function getEnvironment(env) {
                if (!env) {
                    return process.env;
                }
                var result = Object.create(null);
                Object.keys(process.env).forEach(function (key) { return result[key] = process.env[key]; });
                Object.keys(env).forEach(function (key) { return result[key] = env[key]; });
            }
            function startedInDebugMode() {
                var args = process.execArgv;
                if (args) {
                    return args.some(function (arg) { return /^--debug=?/.test(arg) || /^--debug-brk=?/.test(arg); });
                }
                ;
                return false;
            }
            var encoding = this._clientOptions.stdioEncoding || 'utf8';
            var errorHandler = function (error, message, count) {
                _this.handleConnectionError(error, message, count);
            };
            var closeHandler = function () {
                _this.handleConnectionClosed();
            };
            var server = this._serverOptions;
            // We got a function.
            if (is.func(server)) {
                return server().then(function (result) {
                    var info = result;
                    if (info.writer && info.reader) {
                        return createConnection(info.reader, info.writer, errorHandler, closeHandler);
                    }
                    else {
                        var cp_1 = result;
                        return createConnection(cp_1.stdout, cp_1.stdin, errorHandler, closeHandler);
                    }
                });
            }
            var json;
            var runDebug = server;
            if (runDebug.run || runDebug.debug) {
                // We are under debugging. So use debug as well.
                if (typeof v8debug === 'object' || this._forceDebug || startedInDebugMode()) {
                    json = runDebug.debug;
                }
                else {
                    json = runDebug.run;
                }
            }
            else {
                json = server;
            }
            if (json.module) {
                var node_1 = json;
                if (node_1.runtime) {
                    var args_1 = [];
                    var options = node_1.options || Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(function (element) { return args_1.push(element); });
                    }
                    args_1.push(node_1.module);
                    if (node_1.args) {
                        node_1.args.forEach(function (element) { return args_1.push(element); });
                    }
                    var execOptions = Object.create(null);
                    execOptions.cwd = options.cwd || vscode_1.workspace.rootPath;
                    execOptions.env = getEnvironment(options.env);
                    if (node_1.transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args_1.push('--node-ipc');
                    }
                    else if (node_1.transport === TransportKind.stdio) {
                        args_1.push('--stdio');
                    }
                    var process_1 = cp.spawn(node_1.runtime, args_1, execOptions);
                    if (!process_1 || !process_1.pid) {
                        return Promise.reject("Launching server using runtime " + node_1.runtime + " failed.");
                    }
                    this._childProcess = process_1;
                    process_1.stderr.on('data', function (data) { return _this.outputChannel.append(is.string(data) ? data : data.toString(encoding)); });
                    if (node_1.transport === TransportKind.ipc) {
                        process_1.stdout.on('data', function (data) { return _this.outputChannel.append(is.string(data) ? data : data.toString(encoding)); });
                        return Promise.resolve(createConnection(new vscode_jsonrpc_1.IPCMessageReader(process_1), new vscode_jsonrpc_1.IPCMessageWriter(process_1), errorHandler, closeHandler));
                    }
                    else {
                        return Promise.resolve(createConnection(process_1.stdout, process_1.stdin, errorHandler, closeHandler));
                    }
                }
                else {
                    return new Promise(function (resolve, reject) {
                        var args = node_1.args && node_1.args.slice() || [];
                        if (node_1.transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (node_1.transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        var options = node_1.options || Object.create(null);
                        options.execArgv = options.execArgv || [];
                        options.cwd = options.cwd || vscode_1.workspace.rootPath;
                        electron.fork(node_1.module, args || [], options, function (error, cp) {
                            if (error || !cp) {
                                reject(error);
                            }
                            else {
                                _this._childProcess = cp;
                                cp.stderr.on('data', function (data) { return _this.outputChannel.append(is.string(data) ? data : data.toString(encoding)); });
                                if (node_1.transport === TransportKind.ipc) {
                                    cp.stdout.on('data', function (data) { return _this.outputChannel.append(is.string(data) ? data : data.toString(encoding)); });
                                    resolve(createConnection(new vscode_jsonrpc_1.IPCMessageReader(_this._childProcess), new vscode_jsonrpc_1.IPCMessageWriter(_this._childProcess), errorHandler, closeHandler));
                                }
                                else {
                                    resolve(createConnection(cp.stdout, cp.stdin, errorHandler, closeHandler));
                                }
                            }
                        });
                    });
                }
            }
            else if (json.command) {
                var command = json;
                var options = command.options || {};
                options.cwd = options.cwd || vscode_1.workspace.rootPath;
                var process_2 = cp.spawn(command.command, command.args, command.options);
                if (!process_2 || !process_2.pid) {
                    return Promise.reject("Launching server using command " + command.command + " failed.");
                }
                process_2.stderr.on('data', function (data) { return _this.outputChannel.append(is.string(data) ? data : data.toString(encoding)); });
                this._childProcess = process_2;
                return Promise.resolve(createConnection(process_2.stdout, process_2.stdin, errorHandler, closeHandler));
            }
            return Promise.reject(new Error("Unsupported server configuartion " + JSON.stringify(server, null, 4)));
        };
        LanguageClient.prototype.handleConnectionClosed = function () {
            // Check whether this is a normal shutdown in progress or the client stopped normally.
            if (this.state === ClientState.Stopping || this.state === ClientState.Stopped) {
                return;
            }
            this._connectionPromise = undefined;
            this._resolvedConnection = undefined;
            this._childProcess = undefined;
            var action = this._clientOptions.errorHandler.closed();
            if (action === CloseAction.DoNotRestart) {
                this.error('Connection to server got closed. Server will not be restarted.');
                this.state = ClientState.Stopped;
                this.cleanUp();
            }
            else if (action === CloseAction.Restart) {
                this.info('Connection to server got closed. Server will restart.');
                this.cleanUp(false);
                this.state = ClientState.Initial;
                this.start();
            }
        };
        LanguageClient.prototype.handleConnectionError = function (error, message, count) {
            var action = this._clientOptions.errorHandler.error(error, message, count);
            if (action === ErrorAction.Shutdown) {
                this.error('Connection to server is erroring. Shutting down server.');
                this.stop();
            }
        };
        LanguageClient.prototype.checkProcessDied = function (childProcess) {
            if (!childProcess) {
                return;
            }
            setTimeout(function () {
                // Test if the process is still alive. Throws an exception if not
                try {
                    process.kill(childProcess.pid, 0);
                    processes_1.terminate(childProcess);
                }
                catch (error) {
                }
            }, 2000);
        };
        LanguageClient.prototype.hookConfigurationChanged = function (connection) {
            var _this = this;
            if (!this._clientOptions.synchronize.configurationSection) {
                return;
            }
            vscode_1.workspace.onDidChangeConfiguration(function () { return _this.onDidChangeConfiguration(connection); }, this, this._listeners);
            this.onDidChangeConfiguration(connection);
        };
        LanguageClient.prototype.refreshTrace = function (connection, sendNotification) {
            if (sendNotification === void 0) { sendNotification = false; }
            var config = vscode_1.workspace.getConfiguration(this._id);
            var trace = vscode_jsonrpc_1.Trace.Off;
            if (config) {
                trace = vscode_jsonrpc_1.Trace.fromString(config.get('trace.server', 'off'));
            }
            this._trace = trace;
            connection.trace(this._trace, this._tracer, sendNotification);
        };
        LanguageClient.prototype.onDidChangeConfiguration = function (connection) {
            this.refreshTrace(connection, true);
            var keys;
            var configurationSection = this._clientOptions.synchronize.configurationSection;
            if (is.string(configurationSection)) {
                keys = [configurationSection];
            }
            else if (is.stringArray(configurationSection)) {
                keys = configurationSection;
            }
            if (keys) {
                if (this.isConnectionActive()) {
                    connection.didChangeConfiguration({ settings: this.extractSettingsInformation(keys) });
                }
            }
        };
        LanguageClient.prototype.extractSettingsInformation = function (keys) {
            function ensurePath(config, path) {
                var current = config;
                for (var i = 0; i < path.length - 1; i++) {
                    var obj = current[path[i]];
                    if (!obj) {
                        obj = Object.create(null);
                        current[path[i]] = obj;
                    }
                    current = obj;
                }
                return current;
            }
            var result = Object.create(null);
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var index = key.indexOf('.');
                var config = null;
                if (index >= 0) {
                    config = vscode_1.workspace.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
                }
                else {
                    config = vscode_1.workspace.getConfiguration(key);
                }
                if (config) {
                    var path = keys[i].split('.');
                    ensurePath(result, path)[path[path.length - 1]] = config;
                }
            }
            return result;
        };
        LanguageClient.prototype.hookFileEvents = function (_connection) {
            var _this = this;
            var fileEvents = this._clientOptions.synchronize.fileEvents;
            if (!fileEvents) {
                return;
            }
            var watchers;
            if (is.array(fileEvents)) {
                watchers = fileEvents;
            }
            else {
                watchers = [fileEvents];
            }
            if (!watchers) {
                return;
            }
            watchers.forEach(function (watcher) {
                watcher.onDidCreate(function (resource) { return _this.notifyFileEvent({
                    uri: resource.toString(),
                    type: protocol_1.FileChangeType.Created
                }); }, null, _this._listeners);
                watcher.onDidChange(function (resource) { return _this.notifyFileEvent({
                    uri: resource.toString(),
                    type: protocol_1.FileChangeType.Changed
                }); }, null, _this._listeners);
                watcher.onDidDelete(function (resource) { return _this.notifyFileEvent({
                    uri: resource.toString(),
                    type: protocol_1.FileChangeType.Deleted
                }); }, null, _this._listeners);
            });
        };
        LanguageClient.prototype.initRegistrationHandlers = function (_connection) {
            var _this = this;
            var syncedDocuments = new Map();
            var logger = function (type, error) { _this.logFailedRequest(type, error); };
            this._registeredHandlers.set(protocol_1.DidOpenTextDocumentNotification.type.method, new DidOpenTextDocumentFeature(this, syncedDocuments));
            this._registeredHandlers.set(protocol_1.DidChangeTextDocumentNotification.type.method, new DidChangeTextDocumentFeature(this));
            this._registeredHandlers.set(protocol_1.WillSaveTextDocumentNotification.type.method, new DocumentNotifiactions(this, vscode_1.workspace.onWillSaveTextDocument, protocol_1.WillSaveTextDocumentNotification.type, function (willSaveEvent) { return _this._c2p.asWillSaveTextDocumentParams(willSaveEvent); }, function (selectors, willSaveEvent) { return DocumentNotifiactions.textDocumentFilter(selectors, willSaveEvent.document); }));
            this._registeredHandlers.set(protocol_1.WillSaveTextDocumentWaitUntilRequest.type.method, new WillSaveWaitUntilFeature(this));
            this._registeredHandlers.set(protocol_1.DidSaveTextDocumentNotification.type.method, new DocumentNotifiactions(this, vscode_1.workspace.onDidSaveTextDocument, protocol_1.DidSaveTextDocumentNotification.type, function (textDocument) { return _this._c2p.asSaveTextDocumentParams(textDocument); }, DocumentNotifiactions.textDocumentFilter));
            this._registeredHandlers.set(protocol_1.DidCloseTextDocumentNotification.type.method, new DidCloseTextDocumentFeature(this, syncedDocuments));
            this._registeredHandlers.set(protocol_1.CompletionRequest.type.method, new LanguageFeature(function (options) { return _this.createCompletionProvider(options); }));
            this._registeredHandlers.set(protocol_1.HoverRequest.type.method, new LanguageFeature(function (options) { return _this.createHoverProvider(options); }));
            this._registeredHandlers.set(protocol_1.SignatureHelpRequest.type.method, new LanguageFeature(function (options) { return _this.createSignatureHelpProvider(options); }));
            this._registeredHandlers.set(protocol_1.DefinitionRequest.type.method, new LanguageFeature(function (options) { return _this.createDefinitionProvider(options); }));
            this._registeredHandlers.set(protocol_1.ReferencesRequest.type.method, new LanguageFeature(function (options) { return _this.createReferencesProvider(options); }));
            this._registeredHandlers.set(protocol_1.DocumentHighlightRequest.type.method, new LanguageFeature(function (options) { return _this.createDocumentHighlightProvider(options); }));
            this._registeredHandlers.set(protocol_1.DocumentSymbolRequest.type.method, new LanguageFeature(function (options) { return _this.createDocumentSymbolProvider(options); }));
            this._registeredHandlers.set(protocol_1.WorkspaceSymbolRequest.type.method, new LanguageFeature(function (options) { return _this.createWorkspaceSymbolProvider(options); }));
            this._registeredHandlers.set(protocol_1.CodeActionRequest.type.method, new LanguageFeature(function (options) { return _this.createCodeActionsProvider(options); }));
            this._registeredHandlers.set(protocol_1.CodeLensRequest.type.method, new LanguageFeature(function (options) { return _this.createCodeLensProvider(options); }));
            this._registeredHandlers.set(protocol_1.DocumentFormattingRequest.type.method, new LanguageFeature(function (options) { return _this.createDocumentFormattingProvider(options); }));
            this._registeredHandlers.set(protocol_1.DocumentRangeFormattingRequest.type.method, new LanguageFeature(function (options) { return _this.createDocumentRangeFormattingProvider(options); }));
            this._registeredHandlers.set(protocol_1.DocumentOnTypeFormattingRequest.type.method, new LanguageFeature(function (options) { return _this.createDocumentOnTypeFormattingProvider(options); }));
            this._registeredHandlers.set(protocol_1.RenameRequest.type.method, new LanguageFeature(function (options) { return _this.createRenameProvider(options); }));
            this._registeredHandlers.set(protocol_1.DocumentLinkRequest.type.method, new LanguageFeature(function (options) { return _this.createDocumentLinkProvider(options); }));
            this._registeredHandlers.set(protocol_1.ExecuteCommandRequest.type.method, new ExecuteCommandFeature(this, logger));
        };
        LanguageClient.prototype.handleRegistrationRequest = function (params) {
            var _this = this;
            return new Promise(function (resolve, _reject) {
                params.registrations.forEach(function (element) {
                    var handler = _this._registeredHandlers.get(element.method);
                    var options = element.registerOptions || {};
                    options.documentSelector = options.documentSelector || _this._clientOptions.documentSelector;
                    if (handler) {
                        handler.register(element);
                    }
                });
                resolve();
            });
        };
        LanguageClient.prototype.handleUnregistrationRequest = function (params) {
            var _this = this;
            return new Promise(function (resolve, _reject) {
                params.unregisterations.forEach(function (element) {
                    var handler = _this._registeredHandlers.get(element.method);
                    if (handler) {
                        handler.unregister(element.id);
                    }
                });
                resolve();
            });
        };
        LanguageClient.prototype.handleApplyWorkspaceEdit = function (params) {
            // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
            // However doing it here adds some safety since the server can lag more behind then an extension.
            var workspaceEdit = params.edit;
            var openTextDocuments = new Map();
            vscode_1.workspace.textDocuments.forEach(function (document) { return openTextDocuments.set(document.uri.toString(), document); });
            var versionMismatch = false;
            if (workspaceEdit.changes) {
                for (var _i = 0, _a = workspaceEdit.changes; _i < _a.length; _i++) {
                    var change = _a[_i];
                    if (change.textDocument.version && change.textDocument.version >= 0) {
                        var textDocument = openTextDocuments.get(change.textDocument.uri);
                        if (textDocument && textDocument.version !== change.textDocument.version) {
                            versionMismatch = true;
                            break;
                        }
                    }
                }
            }
            if (versionMismatch) {
                return Promise.resolve({ applied: false });
            }
            return vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then(function (value) { return { applied: value }; });
        };
        ;
        LanguageClient.prototype.hookCapabilities = function (_connection) {
            var documentSelector = this._clientOptions.documentSelector;
            if (!documentSelector) {
                return;
            }
            var selectorOptions = { documentSelector: documentSelector };
            if (this._capabilites.completionProvider) {
                var options = Object.assign({}, selectorOptions, this._capabilites.completionProvider);
                this._registeredHandlers.get(protocol_1.CompletionRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: options });
            }
            if (this._capabilites.hoverProvider) {
                this._registeredHandlers.get(protocol_1.HoverRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.signatureHelpProvider) {
                var options = Object.assign({}, selectorOptions, this._capabilites.signatureHelpProvider);
                this._registeredHandlers.get(protocol_1.SignatureHelpRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: options });
            }
            if (this._capabilites.definitionProvider) {
                this._registeredHandlers.get(protocol_1.DefinitionRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.referencesProvider) {
                this._registeredHandlers.get(protocol_1.ReferencesRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.documentHighlightProvider) {
                this._registeredHandlers.get(protocol_1.DocumentHighlightRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.documentSymbolProvider) {
                this._registeredHandlers.get(protocol_1.DocumentSymbolRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.workspaceSymbolProvider) {
                this._registeredHandlers.get(protocol_1.WorkspaceSymbolRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.codeActionProvider) {
                this._registeredHandlers.get(protocol_1.CodeActionRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.codeLensProvider) {
                var options = Object.assign({}, selectorOptions, this._capabilites.codeLensProvider);
                this._registeredHandlers.get(protocol_1.CodeLensRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: options });
            }
            if (this._capabilites.documentFormattingProvider) {
                this._registeredHandlers.get(protocol_1.DocumentFormattingRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.documentRangeFormattingProvider) {
                this._registeredHandlers.get(protocol_1.DocumentRangeFormattingRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.documentOnTypeFormattingProvider) {
                var options = Object.assign({}, selectorOptions, this._capabilites.documentOnTypeFormattingProvider);
                this._registeredHandlers.get(protocol_1.DocumentOnTypeFormattingRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: options });
            }
            if (this._capabilites.renameProvider) {
                this._registeredHandlers.get(protocol_1.RenameRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: Object.assign({}, selectorOptions) });
            }
            if (this._capabilites.documentLinkProvider) {
                var options = Object.assign({}, selectorOptions, this._capabilites.documentLinkProvider);
                this._registeredHandlers.get(protocol_1.DocumentLinkRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: options });
            }
            if (this._capabilites.executeCommandProvider) {
                var options = Object.assign({}, this._capabilites.executeCommandProvider);
                this._registeredHandlers.get(protocol_1.ExecuteCommandRequest.type.method).register({ id: UUID.generateUuid(), registerOptions: options });
            }
        };
        LanguageClient.prototype.logFailedRequest = function (type, error) {
            this.error("Request " + type.method + " failed.", error);
        };
        LanguageClient.prototype.createCompletionProvider = function (options) {
            var _this = this;
            var triggerCharacters = options.triggerCharacters || [];
            return vscode_1.languages.registerCompletionItemProvider.apply(vscode_1.languages, [options.documentSelector, {
                provideCompletionItems: function (document, position, token) {
                    return _this.sendRequest(protocol_1.CompletionRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asCompletionResult, function (error) {
                        _this.logFailedRequest(protocol_1.CompletionRequest.type, error);
                        return Promise.resolve([]);
                    });
                },
                resolveCompletionItem: options.resolveProvider
                    ? function (item, token) {
                        return _this.sendRequest(protocol_1.CompletionResolveRequest.type, _this._c2p.asCompletionItem(item), token).then(_this._p2c.asCompletionItem, function (error) {
                            _this.logFailedRequest(protocol_1.CompletionResolveRequest.type, error);
                            return Promise.resolve(item);
                        });
                    }
                    : undefined
            }].concat(triggerCharacters));
        };
        LanguageClient.prototype.createHoverProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerHoverProvider(options.documentSelector, {
                provideHover: function (document, position, token) {
                    return _this.sendRequest(protocol_1.HoverRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asHover, function (error) {
                        _this.logFailedRequest(protocol_1.HoverRequest.type, error);
                        return Promise.resolve(null);
                    });
                }
            });
        };
        LanguageClient.prototype.createSignatureHelpProvider = function (options) {
            var _this = this;
            var triggerCharacters = options.triggerCharacters || [];
            return vscode_1.languages.registerSignatureHelpProvider.apply(vscode_1.languages, [options.documentSelector, {
                provideSignatureHelp: function (document, position, token) {
                    return _this.sendRequest(protocol_1.SignatureHelpRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asSignatureHelp, function (error) {
                        _this.logFailedRequest(protocol_1.SignatureHelpRequest.type, error);
                        return Promise.resolve(null);
                    });
                }
            }].concat(triggerCharacters));
        };
        LanguageClient.prototype.createDefinitionProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerDefinitionProvider(options.documentSelector, {
                provideDefinition: function (document, position, token) {
                    return _this.sendRequest(protocol_1.DefinitionRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asDefinitionResult, function (error) {
                        _this.logFailedRequest(protocol_1.DefinitionRequest.type, error);
                        return Promise.resolve(null);
                    });
                }
            });
        };
        LanguageClient.prototype.createReferencesProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerReferenceProvider(options.documentSelector, {
                provideReferences: function (document, position, options, token) {
                    return _this.sendRequest(protocol_1.ReferencesRequest.type, _this._c2p.asReferenceParams(document, position, options), token).then(_this._p2c.asReferences, function (error) {
                        _this.logFailedRequest(protocol_1.ReferencesRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            });
        };
        LanguageClient.prototype.createDocumentHighlightProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, {
                provideDocumentHighlights: function (document, position, token) {
                    return _this.sendRequest(protocol_1.DocumentHighlightRequest.type, _this._c2p.asTextDocumentPositionParams(document, position), token).then(_this._p2c.asDocumentHighlights, function (error) {
                        _this.logFailedRequest(protocol_1.DocumentHighlightRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            });
        };
        LanguageClient.prototype.createDocumentSymbolProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, {
                provideDocumentSymbols: function (document, token) {
                    return _this.sendRequest(protocol_1.DocumentSymbolRequest.type, _this._c2p.asDocumentSymbolParams(document), token).then(_this._p2c.asSymbolInformations, function (error) {
                        _this.logFailedRequest(protocol_1.DocumentSymbolRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            });
        };
        LanguageClient.prototype.createWorkspaceSymbolProvider = function (_options) {
            var _this = this;
            return vscode_1.languages.registerWorkspaceSymbolProvider({
                provideWorkspaceSymbols: function (query, token) {
                    return _this.sendRequest(protocol_1.WorkspaceSymbolRequest.type, { query: query }, token).then(_this._p2c.asSymbolInformations, function (error) {
                        _this.logFailedRequest(protocol_1.WorkspaceSymbolRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            });
        };
        LanguageClient.prototype.createCodeActionsProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerCodeActionsProvider(options.documentSelector, {
                provideCodeActions: function (document, range, context, token) {
                    var params = {
                        textDocument: _this._c2p.asTextDocumentIdentifier(document),
                        range: _this._c2p.asRange(range),
                        context: _this._c2p.asCodeActionContext(context)
                    };
                    return _this.sendRequest(protocol_1.CodeActionRequest.type, params, token).then(_this._p2c.asCommands, function (error) {
                        _this.logFailedRequest(protocol_1.CodeActionRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            });
        };
        LanguageClient.prototype.createCodeLensProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerCodeLensProvider(options.documentSelector, {
                provideCodeLenses: function (document, token) {
                    return _this.sendRequest(protocol_1.CodeLensRequest.type, _this._c2p.asCodeLensParams(document), token).then(_this._p2c.asCodeLenses, function (error) {
                        _this.logFailedRequest(protocol_1.CodeLensRequest.type, error);
                        return Promise.resolve([]);
                    });
                },
                resolveCodeLens: (options.resolveProvider)
                    ? function (codeLens, token) {
                        return _this.sendRequest(protocol_1.CodeLensResolveRequest.type, _this._c2p.asCodeLens(codeLens), token).then(_this._p2c.asCodeLens, function (error) {
                            _this.logFailedRequest(protocol_1.CodeLensResolveRequest.type, error);
                            return codeLens;
                        });
                    }
                    : undefined
            });
        };
        LanguageClient.prototype.createDocumentFormattingProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, {
                provideDocumentFormattingEdits: function (document, options, token) {
                    var params = {
                        textDocument: _this._c2p.asTextDocumentIdentifier(document),
                        options: _this._c2p.asFormattingOptions(options)
                    };
                    return _this.sendRequest(protocol_1.DocumentFormattingRequest.type, params, token).then(_this._p2c.asTextEdits, function (error) {
                        _this.logFailedRequest(protocol_1.DocumentFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            });
        };
        LanguageClient.prototype.createDocumentRangeFormattingProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, {
                provideDocumentRangeFormattingEdits: function (document, range, options, token) {
                    var params = {
                        textDocument: _this._c2p.asTextDocumentIdentifier(document),
                        range: _this._c2p.asRange(range),
                        options: _this._c2p.asFormattingOptions(options)
                    };
                    return _this.sendRequest(protocol_1.DocumentRangeFormattingRequest.type, params, token).then(_this._p2c.asTextEdits, function (error) {
                        _this.logFailedRequest(protocol_1.DocumentRangeFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            });
        };
        LanguageClient.prototype.createDocumentOnTypeFormattingProvider = function (options) {
            var _this = this;
            var moreTriggerCharacter = options.moreTriggerCharacter || [];
            return vscode_1.languages.registerOnTypeFormattingEditProvider.apply(vscode_1.languages, [options.documentSelector, {
                provideOnTypeFormattingEdits: function (document, position, ch, options, token) {
                    var params = {
                        textDocument: _this._c2p.asTextDocumentIdentifier(document),
                        position: _this._c2p.asPosition(position),
                        ch: ch,
                        options: _this._c2p.asFormattingOptions(options)
                    };
                    return _this.sendRequest(protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(_this._p2c.asTextEdits, function (error) {
                        _this.logFailedRequest(protocol_1.DocumentOnTypeFormattingRequest.type, error);
                        return Promise.resolve([]);
                    });
                }
            }, options.firstTriggerCharacter].concat(moreTriggerCharacter));
        };
        LanguageClient.prototype.createRenameProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerRenameProvider(options.documentSelector, {
                provideRenameEdits: function (document, position, newName, token) {
                    var params = {
                        textDocument: _this._c2p.asTextDocumentIdentifier(document),
                        position: _this._c2p.asPosition(position),
                        newName: newName
                    };
                    return _this.sendRequest(protocol_1.RenameRequest.type, params, token).then(_this._p2c.asWorkspaceEdit, function (error) {
                        _this.logFailedRequest(protocol_1.RenameRequest.type, error);
                        Promise.resolve(new Error(error.message));
                    });
                }
            });
        };
        LanguageClient.prototype.createDocumentLinkProvider = function (options) {
            var _this = this;
            return vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, {
                provideDocumentLinks: function (document, token) {
                    return _this.sendRequest(protocol_1.DocumentLinkRequest.type, _this._c2p.asDocumentLinkParams(document), token).then(_this._p2c.asDocumentLinks, function (error) {
                        _this.logFailedRequest(protocol_1.DocumentLinkRequest.type, error);
                        Promise.resolve(new Error(error.message));
                    });
                },
                resolveDocumentLink: options.resolveProvider
                    ? function (link, token) {
                        return _this.sendRequest(protocol_1.DocumentLinkResolveRequest.type, _this._c2p.asDocumentLink(link), token).then(_this._p2c.asDocumentLink, function (error) {
                            _this.logFailedRequest(protocol_1.DocumentLinkResolveRequest.type, error);
                            Promise.resolve(new Error(error.message));
                        });
                    }
                    : undefined
            });
        };
        return LanguageClient;
    }());
    exports.LanguageClient = LanguageClient;
    var SettingMonitor = (function () {
        function SettingMonitor(_client, _setting) {
            this._client = _client;
            this._setting = _setting;
            this._listeners = [];
        }
        SettingMonitor.prototype.start = function () {
            var _this = this;
            vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
            this.onDidChangeConfiguration();
            return new vscode_1.Disposable(function () {
                if (_this._client.needsStop()) {
                    _this._client.stop();
                }
            });
        };
        SettingMonitor.prototype.onDidChangeConfiguration = function () {
            var index = this._setting.indexOf('.');
            var primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
            var rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
            var enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
            if (enabled && this._client.needsStart()) {
                this._client.start();
            }
            else if (!enabled && this._client.needsStop()) {
                this._client.stop();
            }
        };
        return SettingMonitor;
    }());
    exports.SettingMonitor = SettingMonitor;
});
//# sourceMappingURL=main.js.map